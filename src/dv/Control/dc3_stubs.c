/*
** Generated by WorkShop Visual
*/

/*
** WorkShop Visual-generated prelude.
** Do not edit lines before "End of WorkShop Visual generated prelude"
** Lines beginning ** WorkShop Visual Stub indicate a stub
** which will not be output on re-generation
*/

/*
**LIBS: -lXm -lXt -lX11
*/

#include <stdlib.h>
#include <unistd.h> /* Bring in declaration of execlp() */
#include <X11/Xatom.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>

#include <Xm/Xm.h>
#include <Xm/ArrowB.h>
#include <Xm/List.h>
#include <Xm/PushB.h>
#include <Xm/RowColumn.h>
#include <Xm/TextF.h>
#include <Xm/ToggleB.h>
#include <Xm/PushBG.h>
#include <Xm/ToggleBG.h>



extern void XDmanage_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDunmanage_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDpopup_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDpopdown_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDmap_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDunmap_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDenable_link ( Widget w, XtPointer client_data, XtPointer call_data );
extern void XDdisable_link ( Widget w, XtPointer client_data, XtPointer call_data );

/* End of WorkShop Visual generated prelude */













#include <sys/stat.h>
#include <dirent.h>
#include "dc3m.h"

#include "globs.h"

#include <Xm/Text.h>
#include <Xm/DropTrans.h>

extern Display *display;
extern Widget menuDelayText;
extern Widget menuYScaleText;
extern Widget menuColorText;
extern Widget displayTypeText;
extern Widget menuModeText;
extern Widget menuResText;
extern Widget menuRateText;

/* Which plotter, 4 - framer4 or 3 for framer3 */
int plotterNum = 4;

#define  ShowWatchCursor() XDefineCursor(display, XtWindow(shell1), watch_cursor);\
	 		   XSync(display, 0)
#define  ClearWatchCursor() XUndefineCursor(display, XtWindow(shell1))

void SetStringWidget(Widget w, char *s) {
       	Arg al;
	XmString xs = XmStringCreateSimple(s);
	//XtVaSetValues(w, XmNlabelString, xs);
	XtSetArg(al, XmNlabelString, xs);
	XtSetValues(w, &al, 1); 
	XmStringFree(xs);
}

void
updateStatusField() {
  char buf[1024];
  sprintf(buf, "Connected to %s", serverIP);
  SetStringWidget(statusField, buf);
}

void
errorMessage(char *buf)  {
	extern Widget *xd_links;
	SetStringWidget(errorDialogMessage, buf);
	XtManageChild(xd_links[0]);
}

/*
** WorkShop Visual Stub stopButton
*/

void stopButton(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  mb.mtype = 1;
  strcpy (mb.mtext, "0");
  msgsnd (msqid, &mb, MSQSIZE, 0);
  SetStringWidget (actionText,"Stop");
}

/*
** WorkShop Visual Stub pauseButton
*/

void pauseButton(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	//	printf ( "in pause button\n" );
	mb.mtype = 1;
	strcpy ( mb.mtext, "1" );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	SetStringWidget(actionText,"Paused");
}

/*
** WorkShop Visual Stub playButton
*/

void playButton(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  void multiSel(Widget w, XtPointer client_data, XtPointer xt_call_data);
  ShowWatchCursor();
  if (mmMode) {
    printf ( "The Dataviewer is in frame file mode.\n" );
    printf ( "Use Playback to view data from the file, or choose New Configuration to re-connect the server.\n" );
  } else {
    int nSel = 0;
    if (restoreFile == 1) restore_File(restoreFileName);
    for (i=0; i<16; i++) if (chMarked[i]) nSel++;
    if (!nSel) XmToggleButtonSetState(ch1Select, TRUE, TRUE);

    if (firstTime) startXmgr(1);
    else {
      mb.mtype = 1;
      strcpy ( mb.mtext, "2" );
      if (msgsnd(msqid, &mb, MSQSIZE, 0) == -1)
	fprintf(stderr, "Error: failed to send an IPC message\n");
    }
    SetStringWidget(actionText, "Running...");
  }
  ClearWatchCursor();
}

/*
** WorkShop Visual Stub Select0
*/

void Select0(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "0" );
}

/*
** WorkShop Visual Stub Select1
*/

void Select1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "1" );
}

/*
** WorkShop Visual Stub Select2
*/

void Select2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "2" );
}

/*
** WorkShop Visual Stub Select3
*/

void Select3(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "3" );
}

/*
** WorkShop Visual Stub Select4
*/

void Select4(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "4" );
}

/*
** WorkShop Visual Stub Select5
*/

void Select5(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "5" );
}

/*
** WorkShop Visual Stub Select6
*/

void Select6(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "6" );
}

/*
** WorkShop Visual Stub Select7
*/

void Select7(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "7" );
}

/*
** WorkShop Visual Stub Select8
*/

void Select8(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "8" );
}

/*
** WorkShop Visual Stub Select9
*/

void Select9(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "9" );
}

/*
** WorkShop Visual Stub Select10
*/

void Select10(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "10" );
}

/*
** WorkShop Visual Stub Select11
*/

void Select11(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "11" );
}

/*
** WorkShop Visual Stub Select12
*/

void Select12(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "12" );
}

/*
** WorkShop Visual Stub Select13
*/

void Select13(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "13" );
}

/*
** WorkShop Visual Stub Select14
*/

void Select14(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "14" );
}

/*
** WorkShop Visual Stub Select15
*/

void Select15(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "15" );
}

/*
** WorkShop Visual Stub Select16
*/

void Select16(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "16" );
}

/*
** WorkShop Visual Stub Select20
*/

void Select20(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "20" );
}

/*
** WorkShop Visual Stub Select30
*/

void Select30(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "30" );
}

/*
** WorkShop Visual Stub Select32
*/

void Select32(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "32" );
}

/*
** WorkShop Visual Stub Select40
*/

void Select40(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "40" );
}

/*
** WorkShop Visual Stub Select60
*/

void Select60(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "60" );
}

/*
** WorkShop Visual Stub Select64
*/

void Select64(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "64" );
}

/*
** WorkShop Visual Stub Select80
*/

void Select80(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "80" );
}

/*
** WorkShop Visual Stub Select100
*/

void Select100(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "100" );
}

/*
** WorkShop Visual Stub Select128
*/

void Select128(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "128" );
}

void Select256(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "256" );
}

void Select512(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "512" );
}

/*
** WorkShop Visual Stub Select200
*/

void Select200(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "200" );
}

/*
** WorkShop Visual Stub Select400
*/

void Select400(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "400" );
}

/*
** WorkShop Visual Stub Select500
*/

void Select500(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "500" );
}

/*
** WorkShop Visual Stub Select600
*/

void Select600(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "600" );
}

/*
** WorkShop Visual Stub Select800
*/

void Select800(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "800" );
}

/*
** WorkShop Visual Stub Select1000
*/

void Select1000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "1000" );
}

/*
** WorkShop Visual Stub Select2000
*/

void Select2000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "2000" );
}

/*
** WorkShop Visual Stub Select4000
*/

void Select4000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "4000" );
}

/*
** WorkShop Visual Stub Select6000
*/

void Select6000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "6000" );
}

/*
** WorkShop Visual Stub Select8000
*/

void Select8000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "8000" );
}

/*
** WorkShop Visual Stub Select10000
*/

void Select10000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "10000" );
}

/*
** WorkShop Visual Stub Select12000
*/

void Select12000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "12000" );
}

/*
** WorkShop Visual Stub Select14000
*/

void Select14000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "14000" );
}

/*
** WorkShop Visual Stub Select16000
*/

void Select16000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "16000" );
}

/*
** WorkShop Visual Stub Select18000
*/

void Select18000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "18000" );
}

/*
** WorkShop Visual Stub Select20000
*/

void Select20000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "20000" );
}

/*
** WorkShop Visual Stub Select22000
*/

void Select22000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "22000" );
}

/*
** WorkShop Visual Stub Select24000
*/

void Select24000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "24000" );
}

/*
** WorkShop Visual Stub Select26000
*/

void Select26000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "26000" );
}

/*
** WorkShop Visual Stub Select28000
*/

void Select28000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "28000" );
}

/*
** WorkShop Visual Stub Select32000
*/

void Select32000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "32000" );
}


/*
** WorkShop Visual Stub SelectN2
*/

void SelectN2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-2" );
}

/*
** WorkShop Visual Stub SelectN4
*/

void SelectN4(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-4" );
}

/*
** WorkShop Visual Stub SelectN8
*/

void SelectN8(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-8" );
}

/*
** WorkShop Visual Stub SelectN16
*/

void SelectN16(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-16" );
}

/*
** WorkShop Visual Stub SelectN100
*/

void SelectN100(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-100" );
}

/*
** WorkShop Visual Stub SelectN200
*/

void SelectN200(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-200" );
}

/*
** WorkShop Visual Stub SelectN400
*/

void SelectN400(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-400" );
}

/*
** WorkShop Visual Stub SelectN600
*/

void SelectN600(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-600" );
}

/*
** WorkShop Visual Stub SelectN800
*/

void SelectN800(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-800" );
}

/*
** WorkShop Visual Stub SelectN1000
*/

void SelectN1000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-1000" );
}


/*
** WorkShop Visual Stub SelectN2000
*/

void SelectN2000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-2000" );
}

/*
** WorkShop Visual Stub SelectN4000
*/

void SelectN4000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-4000" );
}

/*
** WorkShop Visual Stub SelectN6000
*/

void SelectN6000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-6000" );
}

/*
** WorkShop Visual Stub SelectN8000
*/

void SelectN8000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-8000" );
}

/*
** WorkShop Visual Stub SelectN10000
*/

void SelectN10000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-10000" );
}

/*
** WorkShop Visual Stub SelectN12000
*/

void SelectN12000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-12000" );
}

/*
** WorkShop Visual Stub SelectN14000
*/

void SelectN14000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-14000" );
}

/*
** WorkShop Visual Stub SelectN16000
*/

void SelectN16000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-16000" );
}

/*
** WorkShop Visual Stub SelectN18000
*/

void SelectN18000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-18000" );
}

/*
** WorkShop Visual Stub SelectN20000
*/

void SelectN20000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-20000" );
}

/*
** WorkShop Visual Stub SelectN22000
*/

void SelectN22000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-22000" );
}

/*
** WorkShop Visual Stub SelectN24000
*/

void SelectN24000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-24000" );
}

/*
** WorkShop Visual Stub SelectN26000
*/

void SelectN26000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-26000" );
}

/*
** WorkShop Visual Stub SelectN28000
*/

void SelectN28000(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "-28000" );
}

/*
** WorkShop Visual Stub SelTimeNow
*/

void SelTimeNow(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
char num[4], tempst[32], tmpstr1[100];
unsigned long processID = 0;
time_t temptime;
FILE *fp;

	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	/* frame dir & trend */
	/*if ( mmMode == 2 && trend ) { 
	  printf ( "Time period is not selectable when opening trend frame files.\n" );
	  totalPlay.days = 0;
	  totalPlay.hours = 0;
	  totalPlay.mins = 0;
	  totalPlay.secs = 0;
	  startyr = 0;
	  startmo = 0;
	  startda = 0;
	  starthr = 0;
	  startmn = 0;
	  startsc = 0;
	}
	else*/ if ( mmMode == 0 ) { /* server */
	  //printMessage("Requesting current time...", 0);
	  if (DataTimeNow(serverIP, serverPort) == 0) {
	     DataTimestamp(tempst);
	     temptime = DataTimeGps();
	  } else {
	     sprintf(tmpstr1, "Couldn't connect to %s", serverIP);
	     errorMessage(tmpstr1);
	  }
	  //printf ( "Done requesting current time\n" );
	}
	else { /* frame file */
	  //printf ( "Requesting the available time period...\n" );
	  sprintf ( tmpstr1, "/tmp/%sframetime", iniDir );
	  fp = fopen( tmpstr1, "r" );
	  if ( fp == NULL ) {
	    printf ( "Can't open file: %s\n", tmpstr1 );
	    printMessage("Error in obtaining time period. Make sure frame file has been opened", 0);
	    return;
	  }
	  get_a_line(fp, tmpstr1);
	  get_a_line(fp, tmpstr1);
	  fgps0 = atoi(tmpstr1); 
	  get_a_line(fp, tmpstr1);
	  fgps1 = atoi(tmpstr1); 
	  fclose(fp);
	  fgpsdur = fgps1 - fgps0;
	  if (startstop == 0 ) {
	    DataGPStoUTC(fgps0, tempst);
	    printf ( "Set start time %s (%ld)\n", tempst, fgps0 );
	    temptime = fgps0;
	  }
	  else {
	    DataGPStoUTC(fgps1, tempst);
	    printf ( "Set stop time %s (%ld)\n", tempst, fgps1 );
	    temptime = fgps1;
	  }
	  printf ( "Maximum duration: %ld seconds = ", fgpsdur );
	  totalPlay.mins = 0;
	  totalPlay.hours = 0;
	  totalPlay.days = 0;
	  totalPlay.secs = fgpsdur % 60;
	  fgpsdur -= totalPlay.secs;
	  if (fgpsdur > 0) {
	    totalPlay.mins = (fgpsdur % 3600)/60;
	    fgpsdur -= totalPlay.mins;
	    if (fgpsdur > 0) {
	      totalPlay.hours = (fgpsdur % (24*3600))/3600;
	      fgpsdur -= totalPlay.hours;
	      if (fgpsdur > 0) {
		totalPlay.days = fgpsdur / (24*3600);
	      }
	    }
	  }
	  printf ( "%d:%d:%d:%d\n", totalPlay.days,totalPlay.hours,totalPlay.mins,totalPlay.secs);
          sprintf ( num, "%d", totalPlay.days );
	  XmTextFieldSetString(refTimeDay, num);
          sprintf ( num, "%d", totalPlay.hours );
	  XmTextFieldSetString(refTimeHr, num);
          sprintf ( num, "%d", totalPlay.mins );
	  XmTextFieldSetString(refTimeMin, num);
          sprintf ( num, "%d", totalPlay.secs );
	  XmTextFieldSetString(refTimeSec, num);
	}
	sscanf ( tempst, "%d-%d-%d-%d-%d-%d",&startyr,&startmo,&startda,&starthr,&startmn,&startsc );
	if ( startyr < 10 )
	  sprintf ( num, "0%d", startyr );
	else
	  sprintf ( num, "%d", startyr );
	XmTextFieldSetString(playYr, num);
	sprintf ( num, "%d", startmo );
	XmTextFieldSetString(playMo, num);
	sprintf ( num, "%d", startda );
	XmTextFieldSetString(playDa, num);
	sprintf ( num, "%d", starthr );
	XmTextFieldSetString(playHr, num);
	sprintf ( num, "%d", startmn );
	XmTextFieldSetString(playMn, num);
	sprintf ( num, "%d", startsc );
	XmTextFieldSetString(playSc, num);
	sprintf ( tempst, "%d", (int) temptime );
	XmTextFieldSetString(gpstime, tempst);
}


/*
** WorkShop Visual Stub LongSel
*/

void LongSel(Widget w, XtPointer client_data, XtPointer call_data)
{
char   tempsr[12]; 

	if ( first ) {
	   XmToggleButtonSetState(lstand, TRUE, TRUE);
	   XmToggleButtonSetState(lrms, TRUE, TRUE);
	   XmToggleButtonSetState(lmax, TRUE, TRUE);
	   XmToggleButtonSetState(lmin, TRUE, TRUE);
	   XmToggleButtonSetState(xgrid, TRUE, TRUE);
	   XmToggleButtonSetState(ygrid, TRUE, TRUE);
	   XmToggleButtonSetState(lutc, TRUE, TRUE);
	   if ( mmMode == 0 ) {
	   XmTextFieldSetString(lIPtext, serverIP);
	   sprintf ( tempsr, "%d", serverPort );
	   XmTextFieldSetString(lPorttext, tempsr);
	   }
	   /* set the channels according to the main panel - once */
	   if ( XmToggleButtonGetState(ch1Select) ) 
	     XmToggleButtonSetState(lch1, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch2Select) ) 
	     XmToggleButtonSetState(lch2, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch3Select) ) 
	     XmToggleButtonSetState(lch3, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch4Select) ) 
	     XmToggleButtonSetState(lch4, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch5Select) ) 
	     XmToggleButtonSetState(lch5, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch6Select) ) 
	     XmToggleButtonSetState(lch6, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch7Select) ) 
	     XmToggleButtonSetState(lch7, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch8Select) ) 
	     XmToggleButtonSetState(lch8, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch9Select) ) 
	     XmToggleButtonSetState(lch8, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch10Select) ) 
	     XmToggleButtonSetState(lch10, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch11Select) ) 
	     XmToggleButtonSetState(lch11, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch12Select) ) 
	     XmToggleButtonSetState(lch12, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch13Select) ) 
	     XmToggleButtonSetState(lch13, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch14Select) ) 
	     XmToggleButtonSetState(lch14, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch15Select) ) 
	     XmToggleButtonSetState(lch15, TRUE, TRUE);
	   if ( XmToggleButtonGetState(ch16Select) ) 
	     XmToggleButtonSetState(lch16, TRUE, TRUE);

	   XmToggleButtonSetState(autoset, TRUE, TRUE);
	   first = 0;
	}
	if ( mmMode )
	  XmToggleButtonSetState(lframe, TRUE, TRUE);
	else
	  XmToggleButtonSetState(lserver, TRUE, TRUE);
	setDecimation();
}


/*
** WorkShop Visual Stub SelectMainMenu
*/

struct DChList allChan[MAX_CHANNELS];
void SelectMainMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
int    j, c, c1, c2;
char   tempname[80];
FILE   *fp, *fp1, *fp2;

	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	mmSelect = atoi(mb.mtext);
	//	printf ( "Main menu select: %d\n", mmSelect );
	if ( mmSelect == MMEXIT ) {  /* exit */
	   mb.mtype = 23;
	   strcpy ( mb.mtext, "1" );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   SetStringWidget(actionText,"Shutting down...");
	   XSync(display, 0);
#if 0
	   if (firstTime == 0)
	     //sleep(3);
#endif
	   exit(0);
	}
	else if ( mmSelect == MMNEW ) { /* new xmgr */
	   if (mmMode)
	     printf ( "The Dataviewer is in frame file mode. Use New Configuration to re-connect to server.\n" );
	   else {
	     /* quit the old one first  */
	     if (firstTime == 0) {
	       mb.mtype = 23;
	       strcpy ( mb.mtext, "0" );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	     }
    	     updateStatusField();
	     sleep(1);
	     startXmgr(0);
	     SetStringWidget(actionText, "Stop");
	   }
	}
	else if ( mmSelect ==  MMSAVE) { /* save */
	   if ( saveCalled == 0 ){
              getcwd(currentDir, sizeof(currentDir));
	      if ( strcmp(currentDir, "/") != 0 )
	         strcat ( currentDir, "/save.xml" );
	      saveFileName = currentDir;
	      saveCalled = 1;
	   }
	   XmTextFieldSetString(savefile,saveFileName);
           nseldir = -1;
	   Ashowlist();
	}
	else if ( mmSelect ==  MMRESTORE) { /* restore */
	   if ( saveCalled == 0 ){
	      getcwd(currentDir, sizeof(currentDir));
	      if ( strcmp(currentDir, "/") != 0 )
		 strcat ( currentDir, "/save.xml" );
	      saveFileName = currentDir;
	      saveCalled = 1;
           }
	   if ( restoreFile == 1 ){
	      saveFileName = restoreFileName;
	      saveCalled = 1;
           }
	   XmTextFieldSetString(savefile,saveFileName);
           nseldir = -1;
	   Ashowlist();
	}
	else if ( mmSelect == MMSIG ) {  /* signal selection */
	  if (showSig == 0) {
	    fastslow = SFAST;
	    XmToggleButtonSetState(sfast,  TRUE, TRUE);
	    ShowGroupchList(1);
	    showSig = 1;
	    if (restoreFile == 1) 
	      restore_File(restoreFileName);
	  }
	  else
	    ShowGroupchList(0);
	  //	  printf ( "Called Sig Selection Window\n" );
	}
	else if ( mmSelect == MMLONG ) {  /* long playback */
	  //	  printf ( "Show Long Playback Control\n" );
	  //LongSel();
	}
	else if ( mmSelect == MMPRINT ) {  /* print */
	  //	  printf ( "called PRINT TO FILE\n" );
	  mb.mtype = 27;
	  strcpy ( mb.mtext, "0" );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	}
	else if ( mmSelect == MMCONF ) {  /* reconnect */
	  if ( mmMode ) {
	    mmMode = 0;
	    XmTextFieldSetString(lIPtext, serverIP);
	    sprintf ( tempname, "%d", serverPort );
	    XmTextFieldSetString(lPorttext, tempname);
	  }
	  printf ( "Re Configuring...\n" );
	  sprintf ( tempname, "%s",  serverIP );
	  if ( DataSimpleConnect(tempname, serverPort) ) {
	    ;
	    //fprintf ( stderr,"dc3: connection to Data Server failed. Please make sure if the Server is running and try again.\n" );
	  }
	  else {
	    sprintf ( tempname, "/tmp/%schannelset0",  iniDir );
	    //printf ( "writing channel information to file: %s\n", tempname );
	    fp = fopen(tempname, "w");
	    if ( fp == NULL ) {
	      printf ( "Fatal error: Can't open writing file: %s. Please save your settings, exit Dataviewer and start again.\n", tempname );
	    }
	    sprintf ( tempname, "/tmp/%schannelset_dmt",  iniDir );
	    //printf ( "writing DMT channel information to file: %s\n", tempname );
	    fp1 = fopen(tempname, "w");
	    sprintf ( tempname, "/tmp/%schannelset_obs",  iniDir );
	    //printf ( "writing Obsolete channel information to file: %s\n", tempname );
	    fp2 = fopen(tempname, "w");
	    if ( fp == NULL ) {
	      printf ( "Fatal error: Can't open writing file: %s. Please save your settings, exit Dataviewer and start again.\n", tempname );
	    }
	    else {
	      c = DataChanList(allChan);
	      c1 = 0;
	      c2 = 0;
	      for ( j=0; j<c; j++ ) { /* count DMT & Obsolete channels */
		if (allChan[j].group_num == 1000) 
		  c1++;
		else if (allChan[j].group_num == 1001) 
		  c2++;
	      }
	      printf ( "total %d DMT channels\n", c1);
	      printf ( "total %d Obsolete channels\n", c2);
	      fprintf ( fp, "%d\n", c-c1-c2 );
	      fprintf ( fp1, "%d\n", c1 );
	      fprintf ( fp2, "%d\n", c2 );
	      for ( j=0; j<c; j++ ) {
		if (strcmp(allChan[j].units, " ")==0) 
		  strcpy(allChan[j].units, "None");
		if (allChan[j].group_num == 1000) /* DMT channel */ 
		  fprintf ( fp1, "%s %d %s\n", allChan[j].name, allChan[j].rate, allChan[j].units );
		else if (allChan[j].group_num == 1001) /* Obsolete channel */ 
		  fprintf ( fp2, "%s %d %s\n", allChan[j].name, allChan[j].rate, allChan[j].units );
		else
		  fprintf ( fp, "%s %d %s\n", allChan[j].name, allChan[j].rate, allChan[j].units );
	      }
	      fclose(fp);
	      fclose(fp1);
	      fclose(fp2);
	      DataQuit();
	      for ( j=0; j<16; j++ ) {
		sprintf ( chName[j], "%s", allChan[j].name );
		chRate[j] = allChan[j].rate;
		sprintf ( chUnit[j], "%s", allChan[j].units );
	      }
	      if ( c < 16 ) {
		for ( j=c; j<16; j++ ) {
		  sprintf ( chName[j], "0" );
		  chRate[j] = 0;
		  sprintf ( chUnit[j], "0" );
		}
	      }
	      //printf ( "Re-configuring Xmgrace\n" );	  
	      /* don't quit but stop xmgr */
	      if (firstTime == 0) { 
		/* stop */
		SetStringWidget(actionText,"Stop");
		mb.mtype = 1; /* stop */
		strcpy ( mb.mtext, "0" );
		msgsnd(msqid, &mb, MSQSIZE, 0);
		mb.mtype = 11;  /* restoring  */
		sprintf ( mb.mtext, "1" );
		msgsnd ( msqid, &mb, MSQSIZE, 0 );
		mb.mtype = 4;  /* set for GRAPHTIME */
		sprintf ( mb.mtext, "0" ); 
		msgsnd ( msqid, &mb, MSQSIZE, 0 );
		for ( i=0; i<16; i++ ) {
		  mb.mtype = 9;
		  sprintf ( mb.mtext, "%d", i );
		  msgsnd ( msqid, &mb, MSQSIZE, 0 );
		  mb.mtype = 10;
		  sprintf ( mb.mtext, "%d", i+1 );
		  msgsnd ( msqid, &mb, MSQSIZE, 0 );
		  mb.mtype = 3;
		  strcpy ( mb.mtext, chName[i] );
		  msgsnd ( msqid, &mb, MSQSIZE, 0 );
		  mb.mtype = 13;
		  strcpy ( mb.mtext, chUnit[i] );
		  msgsnd ( msqid, &mb, MSQSIZE, 0 );
		}
		mb.mtype = 10;  
		strcpy(mb.mtext, chChange);
		msgsnd ( msqid, &mb, MSQSIZE, 0 );
		mb.mtype = 15; /* set global */
		sprintf ( mb.mtext, "%d", globOn );
		msgsnd(msqid, &mb, MSQSIZE, 0);
		mb.mtype = 11;  /* finished restoring  */
		sprintf ( mb.mtext, "0" );
		msgsnd ( msqid, &mb, MSQSIZE, 0 );		
		mb.mtype = 9;  /* set selected channel */
		sprintf ( mb.mtext, "%d", chSelected ); 
		msgsnd ( msqid, &mb, MSQSIZE, 0 );
		mb.mtype = 22; /* reset Xmgr */
		strcpy ( mb.mtext, "0" );
		msgsnd(msqid, &mb, MSQSIZE, 0);
	      }
	      /* set up control panel */
	      SetStringWidget(sigNamText, chName[chSelected]);
	      ShowGroupchList(1);
	    }
	  }
	}
	
}


/*
** WorkShop Visual Stub saveOKSel
*/

void restoreSettings(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
FILE *fp;
char tmpstr[400], templine[200], term1[200], term2[200], nametag[80];
int  tmpint, chtag, j;
char tempst[16];  /* check version number */
char *restoreFileName = (char *)XmTextFieldGetString(restorefile);

/* What the heck is this ? */
 mb.mtype = 11;  /* restoring  */
 sprintf ( mb.mtext, "1" );
 msgsnd ( msqid, &mb, MSQSIZE, 0 );

 fp = fopen(restoreFileName, "r");
 if (fp == NULL) {
    sprintf ( tmpstr, "Can't open reading file: %s", restoreFileName );
    printMessage(tmpstr, 0);
    return;
 } else {
    sprintf ( tmpstr, "Restoring DataViewer settings from `%s'", saveFileName );
    printMessage(tmpstr, 0);
 }

 get_save_line(fp, tmpstr);
 if (strncmp(tmpstr, "<?xml", 5) != 0) {
    sprintf ( tmpstr, "Error: %s was saved by an older version of Dataviewer (earlier than V9.0). Please convert the file first. See Help->About.", saveFileName);
    printMessage(tmpstr, 0);
    return;
 }
 /* read and process the restore file  */
   while (1) {
     get_save_line(fp, templine);
     if (strcmp(templine, "</DATAVIEWER>") == 0  ) {
       break;
     }
     if (strchr(templine, '/') != NULL) {
       /* process the line  */
       if (string_chop(term1, templine, '<', '>') > 0) {
	 if (strstr(term1, "=") != NULL) {
	   sscanf (term1, "%s ch=\"%d%s", nametag, &chtag, term2 );
	 }
	 else
	   strcpy ( nametag, term1);
       }
       templine[0] = '0';
       if (string_chop(term1, templine, '>', '<') > 0) { /* date is not empty  */
	 if (strcmp( nametag, "VERSION") == 0) {
	   if (term1[0] != version_n[0]) {
	     sprintf ( tmpstr, "Dataviewer %s: %s was saved by Dataviewer version %s",  version_n, saveFileName, term1 );
	     printMessage(tmpstr, 0);
	   }
	 }
	 else if (strcmp( nametag, "CHANNO") == 0) {
	   windowNum = atoi(term1);
	 }
	 else if (strcmp( nametag, "NAME") == 0) {
	   strcpy(chName[chtag-1], term1);
	   sprintf ( tmpstr, "restoring Ch %d Name = %s", chtag, chName[chtag-1] );
	   printMessage(tmpstr, 0);
	 }
	 else if (strcmp( nametag, "RATE") == 0) {
	   chRate[chtag-1]= atoi(term1);
	 }
	 else if (strcmp( nametag, "UNIT") == 0) {
	   strcpy(chUnit[chtag-1], term1);
	 }	 
	 else if (strcmp( nametag, "YMIN") == 0) {
	   strcpy(yAxisMin[chtag-1], term1);
	 }
	 else if (strcmp( nametag, "YMAX") == 0) {
	   strcpy(yAxisMax[chtag-1], term1);
	 }
	 else if (strcmp( nametag, "XSCALE") == 0) {
	   strcpy(xAxisScale[chtag-1], term1);
	 }
	 else if (strcmp( nametag, "XDELAY") == 0) {
	   strcpy(xAxisDelay[chtag-1], term1);
	 }
	 else if (strcmp( nametag, "XYTYPE") == 0) {
	   xyType[chtag-1]= atoi(term1);
	 }
	 else if (strcmp( nametag, "EUNIT") == 0) {
	   eunit[chtag-1]= atoi(term1);
	 }
	 else if (strcmp( nametag, "AUTO") == 0) {
	   autoon[chtag-1]= atoi(term1);
	 }
	 else if (strcmp( nametag, "COLOR") == 0) {
	   gColor[chtag-1]= atoi(term1);
	 }
	 else if (strcmp( nametag, "GRAPHOPTION") == 0) {
	   graphOption = atoi(term1);
	 }
	 else if (strcmp( nametag, "GRAPHMODE") == 0) {
	   graphMode = atoi(term1);
	 }
	 else if (strcmp( nametag, "CHSELECTED") == 0) {
	   chSelected = atoi(term1);
	 }
	 else if (strcmp( nametag, "GLOBAL") == 0) {
	   globOn = atoi(term1);
	   XmToggleButtonSetState(globalOn, globOn, globOn);
	 }
	 else if (strcmp( nametag, "TRIGGER") == 0) {
	   /* set trigger */
	   mb.mtype = 36;  
	   tmpint = atoi(term1);
	   sprintf ( mb.mtext, "%d", tmpint );
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	   XmToggleButtonSetState(trigOn, tmpint, tmpint);
	   mb.mtype = 37;
	   chanTrig = chtag;
	   sprintf ( mb.mtext, "%d", chanTrig );
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	 }
	 else if (strcmp( nametag, "TRIGGERLEV") == 0) {
	   trigLev = atof(term1);
	   mb.mtype = 40;
	   sprintf ( mb.mtext, "%.2f", trigLev );
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	   XmTextFieldSetString(trigLevelText, mb.mtext);
	 }	 
	 else if (strcmp( nametag, "SIGON") == 0) {
	   tmpint = atoi(term1);
	   mb.mtype = 48;  /* set sigOn */
	   sprintf ( mb.mtext, "%d", tmpint );
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	   XmToggleButtonSetState(sigOn, tmpint, tmpint);
	 }
	 else if (strcmp( nametag, "RESOLUTION") == 0) {
	   resolution = atoi(term1);
	   mb.mtype = 25;  /* set resolution */
	   sprintf ( mb.mtext, "%d", resolution); 
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   sprintf ( mb.mtext, "%d", resolution*128 );
	   SetStringWidget(menuResText, mb.mtext);
	 }
	 else if (strcmp( nametag, "REFRESHRATE") == 0) {
	   refreshrate = atoi(term1);
	   mb.mtype = 26;  /* set refreshrate */
	   sprintf ( mb.mtext, "%d", refreshrate); 
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   SetStringWidget(menuRateText, mb.mtext);
	 }
	 else if (strcmp( nametag, "FILTER") == 0) {
	   tmpint = atoi(term1);
	   mb.mtype = 17;  /* set filterOn */
	   sprintf ( mb.mtext, "%d", tmpint ); 
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   XmToggleButtonSetState(filterOn, tmpint, tmpint);
	 }
	 else if (strcmp( nametag, "CHMARKED") == 0) {
	   /* set no. of chans and marked channels*/
	   sscanf ( term1, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &chMarked[0], &chMarked[1], &chMarked[2], &chMarked[3], &chMarked[4], &chMarked[5], &chMarked[6], &chMarked[7], &chMarked[8], &chMarked[9], &chMarked[10], &chMarked[11], &chMarked[12], &chMarked[13], &chMarked[14], &chMarked[15] );
	   channelMarked();
	 }
       }

     }
   }
   /* end of reading restore file  */

 fclose(fp);

 mb.mtype = 4;  
 sprintf ( mb.mtext, "%d", graphOption );
 msgsnd ( msqid, &mb, MSQSIZE, 0 );
 for ( i=0; i<16; i++ ) {
	       mb.mtype = 10;
	       sprintf ( mb.mtext, "%d", i+1 );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 3;
	       strcpy ( mb.mtext, chName[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 13;
	       strcpy ( mb.mtext, chUnit[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 9;
	       sprintf ( mb.mtext, "%d", i );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 5;
	       strcpy ( mb.mtext, yAxisMin[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 6;
	       strcpy ( mb.mtext, yAxisMax[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 7;
	       sprintf ( mb.mtext, "%d", xyType[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 14;
	       sprintf ( mb.mtext, "%d", eunit[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 16;
	       sprintf ( mb.mtext, "%d", autoon[i] );
	       msgsnd ( msqid, &mb, MSQSIZE, 0 );
	       mb.mtype = 8; 
	       strcpy ( mb.mtext, xAxisScale[i] );
	       msgsnd(msqid, &mb, MSQSIZE, 0);
	       mb.mtype = 12; 
	       strcpy ( mb.mtext, xAxisDelay[i] );
	       msgsnd(msqid, &mb, MSQSIZE, 0);
	       mb.mtype = 28; 
	       sprintf ( mb.mtext, "%d", gColor[i] );
	       msgsnd(msqid, &mb, MSQSIZE, 0);
 }
	   mb.mtype = 2;  /* set graph method */
	   sprintf ( mb.mtext, "%d", graphMode ); 
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 15; /* set global */
	   sprintf ( mb.mtext, "%d", globOn );
	   msgsnd(msqid, &mb, MSQSIZE, 0);

	   mb.mtype = 11;  /* finished restoring message */
	   sprintf ( mb.mtext, "0" );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 9;   /* reset chSelect */
	   sprintf ( mb.mtext, "%d", chSelected );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );

	   for ( i=0; i<16; i++ ) {
	     if ( chMarked[i] )
	     switch ( i ) {
             case 0: 
	         XmToggleButtonSetState(ch1Select, TRUE, TRUE);
                 break;
             case 1: 
	         XmToggleButtonSetState(ch2Select, TRUE, TRUE);
                 break;
             case 2: 
	         XmToggleButtonSetState(ch3Select, TRUE, TRUE);
                 break;
             case 3: 
	         XmToggleButtonSetState(ch4Select, TRUE, TRUE);
                 break;
             case 4: 
	         XmToggleButtonSetState(ch5Select, TRUE, TRUE);
                 break;
             case 5: 
	         XmToggleButtonSetState(ch6Select, TRUE, TRUE);
                 break;
             case 6: 
	         XmToggleButtonSetState(ch7Select, TRUE, TRUE);
                 break;
             case 7: 
	         XmToggleButtonSetState(ch8Select, TRUE, TRUE);
                 break;
             case 8: 
	         XmToggleButtonSetState(ch9Select, TRUE, TRUE);
                 break;
             case 9: 
	         XmToggleButtonSetState(ch10Select, TRUE, TRUE);
                 break;
             case 10: 
	         XmToggleButtonSetState(ch11Select, TRUE, TRUE);
                 break;
             case 11: 
	         XmToggleButtonSetState(ch12Select, TRUE, TRUE);
                 break;
             case 12: 
	         XmToggleButtonSetState(ch13Select, TRUE, TRUE);
                 break;
             case 13: 
	         XmToggleButtonSetState(ch14Select, TRUE, TRUE);
                 break;
             case 14: 
	         XmToggleButtonSetState(ch15Select, TRUE, TRUE);
                 break;
             case 15: 
	         XmToggleButtonSetState(ch16Select, TRUE, TRUE);
                 break;
	     }	
	     else
	     switch ( i ) {
             case 0: 
	         XmToggleButtonSetState(ch1Select, FALSE, FALSE);
                 break;
             case 1: 
	         XmToggleButtonSetState(ch2Select, FALSE, FALSE);
                 break;
             case 2: 
	         XmToggleButtonSetState(ch3Select, FALSE, FALSE);
                 break;
             case 3: 
	         XmToggleButtonSetState(ch4Select, FALSE, FALSE);
                 break;
             case 4: 
	         XmToggleButtonSetState(ch5Select, FALSE, FALSE);
                 break;
             case 5: 
	         XmToggleButtonSetState(ch6Select, FALSE, FALSE);
                 break;
             case 6: 
	         XmToggleButtonSetState(ch7Select, FALSE, FALSE);
                 break;
             case 7: 
	         XmToggleButtonSetState(ch8Select, FALSE, FALSE);
                 break;
             case 8: 
	         XmToggleButtonSetState(ch9Select, FALSE, FALSE);
                 break;
             case 9: 
	         XmToggleButtonSetState(ch10Select, FALSE, FALSE);
                 break;
             case 10: 
	         XmToggleButtonSetState(ch11Select, FALSE, FALSE);
                 break;
             case 11: 
	         XmToggleButtonSetState(ch12Select, FALSE, FALSE);
                 break;
             case 12: 
	         XmToggleButtonSetState(ch13Select, FALSE, FALSE);
                 break;
             case 13: 
	         XmToggleButtonSetState(ch14Select, FALSE, FALSE);
                 break;
             case 14: 
	         XmToggleButtonSetState(ch15Select, FALSE, FALSE);
                 break;
             case 15: 
	         XmToggleButtonSetState(ch16Select, FALSE, FALSE);
                 break;
	     }	   
           }	   

	   SetStringWidget(sigNamText, chName[chSelected]);
	   SetStringWidget(menuYScaleText, xyText[xyType[chSelected]]);
	   ShowGroupchList(0);
	   setString();
	   restoreFile = 0;
}

/*
** WorkShop Visual Stub SelResolutionMenu
*/

void SelResolutionMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	//	printf ( "called menu Resolution\n" );
	if ( graphOption == GRAPHTIME) {
	   mb.mtype = 25;
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	   resolution = atoi(mb.mtext);
	   sprintf ( mb.mtext, "%d", resolution*128 );
	   SetStringWidget(menuResText, mb.mtext);
        }
        else {
           fprintf ( stderr,"Can't change Resolution in Trend mode\n" );;
        }
}


/*
** WorkShop Visual Stub SelWinNumberMenu
*/

void SelWinNumberMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	Widget actives[16] = {ch1Select, ch2Select, ch3Select, ch4Select,
				ch5Select, ch6Select, ch7Select, ch8Select,
				ch9Select, ch10Select, ch11Select, ch12Select,
				ch13Select, ch14Select, ch15Select, ch16Select};
	chSelected = atoi(mb.mtext) - 1;
	/* Active selected channel */
	XmToggleButtonSetState(actives[chSelected], (chMarked[chSelected] = 1), 0);
	sprintf ( mb.mtext, "%d", chSelected );
	mb.mtype = 9;
	msgsnd(msqid, &mb, MSQSIZE,0);
	setString();
}

/*
** WorkShop Visual Stub SelWin1
*/

void SelWin1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "1" );
}

/*
** WorkShop Visual Stub SelWin2
*/

void SelWin2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "2" );
}

/*
** WorkShop Visual Stub SelWin3
*/

void SelWin3(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "3" );
}

/*
** WorkShop Visual Stub SelWin4
*/

void SelWin4(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "4" );
}

/*
** WorkShop Visual Stub SelWin5
*/

void SelWin5(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "5" );
}

/*
** WorkShop Visual Stub SelWin6
*/

void SelWin6(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "6" );
}

/*
** WorkShop Visual Stub SelWin7
*/

void SelWin7(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "7" );
}

/*
** WorkShop Visual Stub SelWin8
*/

void SelWin8(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "8" );
}

/*
** WorkShop Visual Stub SelWin9
*/

void SelWin9(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "9" );
}

/*
** WorkShop Visual Stub SelWin10
*/

void SelWin10(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "10" );
}


/*
** WorkShop Visual Stub SelWin11
*/

void SelWin11(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "11" );
}

/*
** WorkShop Visual Stub SelWin12
*/

void SelWin12(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "12" );
}

/*
** WorkShop Visual Stub SelWin13
*/

void SelWin13(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "13" );
}

/*
** WorkShop Visual Stub SelWin14
*/

void SelWin14(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "14" );
}

/*
** WorkShop Visual Stub SelWin15
*/

void SelWin15(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy (  mb.mtext, "15" );
}

/*
** WorkShop Visual Stub SelWin16
*/

void SelWin16(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	strcpy ( mb.mtext, "16" );
}


/*
** WorkShop Visual Stub SelectRateMenu
*/

void SelectRateMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	//	printf ( "called menu Refresh Rate\n" );
	if ( graphOption == GRAPHTIME ) {
	   mb.mtype = 26;
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	   refreshrate = atoi(mb.mtext);
	   SetStringWidget(menuRateText, mb.mtext);
        }
        else {
	   printMessage("Can't change Refresh Rate in Trend mode", 0);
        }
}


/*
** WorkShop Visual Stub trigonSel
*/

void trigonSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	mb.mtype = 36;
	if ( XmToggleButtonGetState(w) )
	   strcpy ( mb.mtext, "0" );
	else
	   strcpy ( mb.mtext, "1" );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	//	printf ( "in Trigger On Button\n" );
}

/*
** WorkShop Visual Stub SelTrigMenu
*/

void SelTrigMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
char tempstring[100];

	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	mb.mtype = 37;
	msgsnd(msqid, &mb, MSQSIZE, 0);
	chanTrig = atoi(mb.mtext);
	//	printf ( "Trigger Channel menu called: %d\n", chanTrig );
}


/*
** WorkShop Visual Stub SelTrigAboveMenu
*/

void SelTrigAboveMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	trigHow = atoi(mb.mtext);
	//	printf ( "Trig Method selected %d\n", trigHow );
	mb.mtype = 39;
	msgsnd(msqid, &mb, MSQSIZE, 0);
}


char *
butifyRate(int rate)
{
	static char buf[128];
	if (rate >= 1024) sprintf(buf, "%dk", rate/1024);
	else sprintf(buf, "%d", rate);
	return buf;
}

char *
dataType(int dt)
{
 	static char *buf[] = {"","short", "int", "long", "float", "double", "complex", "uint" };
	return dt >= 0 && dt < 8? buf[dt]: buf[0];
}

/*
** WorkShop Visual Stub grouplistSel
*/
char thrGroupTemp[100000][MAX_LONG_CHANNEL_NAME_LENGTH+1];
char linetemp[MAX_LONG_CHANNEL_NAME_LENGTH+80], chtemp[MAX_LONG_CHANNEL_NAME_LENGTH+80],     unittemp[MAX_LONG_CHANNEL_NAME_LENGTH+1], gpname[MAX_LONG_CHANNEL_NAME_LENGTH+10];
char tempname[MAX_LONG_CHANNEL_NAME_LENGTH+1], tempname1[MAX_LONG_CHANNEL_NAME_LENGTH+1], tempname2[MAX_LONG_CHANNEL_NAME_LENGTH+1], tempname3[MAX_LONG_CHANNEL_NAME_LENGTH+1],
tempArray[MAX_LONG_CHANNEL_NAME_LENGTH+1];

void grouplistSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  int  *position, pcount;
  int  group, rate, counter, top=0; /* 1-top level, 2 -sec level */
  FILE *fp;
  int  j, k, l, thrGpCnt;

	XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data ;
        /* get selected group list item */
	if ( XmListGetSelectedPos(grouplist, &position, &pcount) ) {
	   sscanf ( groupList[position[0]], "%s", gpname );
	   //printf("Selected %s\n", gpname); 

	   for ( i=0; i<topTotal; i++ ){ /* check if top level */
	     if ( strcmp(gpname, topGroup[i]) == 0 ) {
	       if (openTop[i] == 0) openTop[i] = 1;
	       else openTop[i] = 0;
	       top =1;
	       break;
	     }
	   }
	   for ( i=0; i<totalgroup; i++ ){ /* check if sec level */
	     if ( strcmp(gpname, secGroup[i]) == 0 ) {
	       if (openSec[i] == 0) openSec[i] = 1;
	       else openSec[i] = 0;
	       top =2; 
	       break;
	     }
	   }
	   for ( i=0; i<ttlgrp3rd; i++ ){ /* check if third level */
	     if ( strcmp(gpname, thirdGroup[i]) == 0 ) {
	       if (openThird[i] == 0) openThird[i] = 1;
	       else openThird[i] = 0;
	       top =3; 
	       break;
	     }
	   }
#if 0
	   if (top == 0)
	     printf ( "top = 0\n") ;
	   if ( top == 1)
	     printf ( "Top level group selected: %s\n", gpname );
	   else if ( top == 2 )
	     printf ( "2nd level group selected: %s\n", gpname );
	   else if ( top == 3 )
	     printf ( "3rd level group selected: %s\n", gpname );
#endif
	}
	XmListDeleteAllItems(siglist);
	//XmTextFieldSetString(selsig, "");
	sprintf ( tempname, "/tmp/%schannelset",  iniDir );
	fp = fopen( tempname, "r" );
	if ( fp == NULL ) {
	  printf ( "Can't open file: %s\n", tempname );
	  printMessage("Error in obtaining chan infomation. Please quit the program", 0);
	  return;
	}
	if ( top ) { /* refresh left side */
	   XmListDeleteAllItems(grouplist);
	   counter = 0;
	   for ( i=0; i<topTotal; i++ ){ /* write groupList[] */
	     /* top level */
	     counter ++;
	     strcpy( groupList[counter], topGroup[i] );
	    if (openTop[i] > 0) {
	     /* second level */
	     sprintf ( tempname, "%s:", topGroup[i] );
	     sprintf ( tempname1, "%s-", topGroup[i] );
	     for ( j=0; j<totalgroup; j++ ){
	       //printf( "Test second group %s or %s vs %s\n", tempname, tempname1, secGroup[j]);
	       if ( test_substring(tempname, secGroup[j] ) == 0 
		    || test_substring(tempname1, secGroup[j] ) == 0 ) {
		   counter ++;
		   sprintf ( groupList[counter], "   %s",  secGroup[j] );
		   if ( openSec[j] > 0 ) { /* open second level */
		     int j3;

		     /* third level */
	     	     sprintf (tempname2, "%s", secGroup[j]);
		     for (j3 = 0; j3 < ttlgrp3rd; j3++) {
	       	       if (test_substring(tempname2, thirdGroup[j3] ) == 0) {
		   	 counter ++;
		   	 sprintf (groupList[counter], "      %s",  thirdGroup[j3] );
		   	 if (openThird[j3] > 0) { /* open third level */
		           thrGpCnt = 0;
		           fseek(fp, 0, 0); /* reset the reading file stream */
		           for ( k=0; k<topTotal+totalgroup+3+ttlgrp3rd+1; k++ ){ 
		             get_a_line(fp, linetemp); /* skip first ... lines */
		           }
		           for ( k=0; k<totalchan; k++ ){
		         	get_a_line(fp, linetemp);
		         	sscanf(linetemp, "%s %d %s", chtemp, &rate, unittemp );
		         	//chop_string(chtemp, '_');
				char *p = strchr(chtemp, '_');
				if (p) p = strchr(p+1, '_');
				if (p) *p = 0;
				//printf ("Testing %s %s\n", chtemp, thirdGroup[j3]);
		         	if (test_substring(thirdGroup[j3], chtemp ) == 0) {
			   		strcpy ( thrGroupTemp[thrGpCnt], chtemp );
			   		thrGpCnt++;
		           	}
		           }
			   //printf("thrGpCnt = %d\n", thrGpCnt) ;
		       	   /* sort 4th level string */
		       	   for ( k=0; k<thrGpCnt; k++ ) {
		             for ( l=k+1; l<thrGpCnt; l++) {
			       if ( strcmp(thrGroupTemp[k], thrGroupTemp[l])>0 ){
			         strcpy ( tempArray, thrGroupTemp[k] );
			         strcpy ( thrGroupTemp[k], thrGroupTemp[l] );
			         strcpy ( thrGroupTemp[l], tempArray );
			       }
		             }
		           }
		           if (thrGpCnt > 0) {
		             counter++;
		             sprintf ( groupList[counter], "         %s", thrGroupTemp[0] );
		             if (thrGpCnt > 1) 
			       for ( k=1; k<thrGpCnt; k++ ){
			         /* check for multiple entries  */
			         if (strcmp(thrGroupTemp[k], thrGroupTemp[k-1])) {
			           counter++;
			           sprintf ( groupList[counter], "         %s", thrGroupTemp[k] );
			         }
			       }		     
		           }
			 }
		       } else {
		   	 //openThird[j3] = 0;
		       }
		     }
		   } /* openSec[j] */
		 }
		 else {
		   //openSec[j] = 0;
		 }
	       }
	     } /* openTop[i] */
	   }
	   {
	     XmString *xms = malloc(sizeof(XmString *) * counter);
	     for (i = 0; i < counter; i++) {
	     	char t[MAX_LONG_CHANNEL_NAME_LENGTH+10];
		int l = strlen(groupList[i+1]) - 1;
		strcpy(t, groupList[i+1]);
		if (t[l] == '_') t[l] = 0;
		xms[i] = XmStringCreateSimple(t);
  	     }
	     XmListAddItems(grouplist, xms, counter, 1);
	     for (i = 0; i < counter; i++) XmStringFree(xms[i]);
	     free(xms);
#if 0
	   for ( i=1; i<=counter; i++ ){
	     XmListAddItem(grouplist,XmStringCreateSimple(groupList[i]),i);
	   }
#endif
	   }
	}
	else 
	{ /* a group name is selected, show right side */
	  int dtype = 0;
	  int tp = 0;

	  //printf ( "Group name selected: %s\n", gpname );
	  //printf( "top == 0, gpname = %s\n", gpname); /* JCB */
	  sprintf ( tempname, "%s_", gpname );
	  //printf( "  tempname = %s\n", tempname) ; /* JCB */
	  counter = 0; 
	  for ( i=0; i<topTotal+totalgroup+3+ttlgrp3rd+1; i++ ){ 
	    get_a_line(fp, linetemp); /* skip first ... lines */
	  }
	  //printf("\n\n\n\n ================================================================================\n") ;
	  for ( i=0; i<totalchan; i++ ){
	    get_a_line(fp, linetemp);
	    sscanf(linetemp, "%s %d %s %d %d", chtemp, &rate, unittemp, &dtype, &tp);
	    //printf("Testing %s %s\n", tempname, chtemp); /* JCB */
	    if ( test_substring(tempname, chtemp ) == 0 || strcmp(gpname, chtemp) == 0) {
	      if (dtype == 6) {
		/* Beware, other code relies on the suffix names */
	        sprintf( sigListItem[++counter],"%s.real   (%s, complex)", chtemp, butifyRate(rate));
	        sigListRate[counter] = rate;
	        sprintf( sigListItem[++counter],"%s.img   (%s, complex)", chtemp, butifyRate(rate));
	        sigListRate[counter] = rate;
	        sprintf( sigListItem[++counter],"%s.mag   (%s, complex)", chtemp, butifyRate(rate));
	        sigListRate[counter] = rate;
	        sprintf( sigListItem[++counter],"%s.phs   (%s, complex)", chtemp, butifyRate(rate));
	        sigListRate[counter] = rate;
	      } else {
                counter++;
	        sprintf(sigListItem[counter],"%s   (%s, %s)", chtemp, butifyRate(rate), tp? "testpoint": dataType(dtype) );
	        sigListRate[counter] = rate;
	      }
	    }
	  }
	  sigCounter = counter;
	  resetSigList(1);  /* rank alphabetically */
	}
	fclose(fp);
	free (position);
	return;
}


/*
** WorkShop Visual Stub siglistSel
*/

void siglistSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  int  *position, pcount;
  char tempname[120], temps[140];

  if ( XmListGetSelectedPos(siglist, &position, &pcount) ) {
    selSig = position[0]; 
    sscanf(sigListItem[selSig], "%s %s %s", tempname, temps, unitsel );
    XmTextFieldSetString(selsig, tempname);
  }
  free (position);
  return;
}


/*
** WorkShop Visual Stub signalSelect
*/

void signalSelect(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  int  chanChg;
  char *c;
  char tempstring[MAX_LONG_CHANNEL_NAME_LENGTH+80];

  chanChg = atoi(chChange);
  strcpy(tempstring, (c = (char *)XmTextFieldGetString(selsig)));
  XtFree(c);
  if ( signalVerify (chanChg, tempstring) < 0 ) {
	  //	  printf ( "Ch%d unchanged.\n", chanChg);
	  return;
  }
	
  if (chanChg > 0 && chanChg < 17) {
    Widget vees [16] = {v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16};
    sprintf (tempstring, "%d: %s", chanChg, chName[chanChg-1]);
    XmTextFieldSetString(vees[chanChg-1], "");
    XmTextFieldSetString(vees[chanChg-1], tempstring);
  }
}


/*
** WorkShop Visual Stub SelHelpMenu
*/

void SelHelpMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  char helpadr[100];

  sprintf ( helpadr, "openUrl(http://www.ligo.caltech.edu/~aivanov/Dataviewer)" );
  printf ( "Remote Netscape Command: %s\n", helpadr );
  fproc = fork();
  //printf ( "Fproc = %d\n", fproc );
  if ( fproc == 0 ) {
    if ( fork() == 0 ) {
      execlp("netscape", "netscape", "-remote", helpadr, (char *)NULL );
      perror("netscape error:");
      exit(0);
    } else exit(0);
  } else wait(0);
}

/*
** WorkShop Visual Stub SelYTypelMenu
*/

void SelYTypelMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	if ( globOn ) {
	  for ( i=0; i<16; i++ ) xyType[i] = tempItem;
 	}
	else
	  xyType[chSelected] = tempItem;
	sprintf ( mb.mtext, "%d", xyType[chSelected] );
	//printf ( "Y Scale Type Selected\n" );
	mb.mtype = 7;
	msgsnd(msqid, &mb, MSQSIZE, 0);
	SetStringWidget(menuYScaleText, xyText[xyType[chSelected]]);
}

/*
** WorkShop Visual Stub linearSel
*/

void linearSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	tempItem = 0;
}

/*
** WorkShop Visual Stub logSel
*/

void logSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	tempItem = 1;
}

/*
** WorkShop Visual Stub lnSel
*/

void lnSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	tempItem = 2;
}

/*
** WorkShop Visual Stub expSel
*/

void expSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	tempItem = 3;
}


/*
** WorkShop Visual Stub sigonSel
*/

void sigonSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	mb.mtype = 48;
	if (XmToggleButtonGetState(w) == 0)
	   strcpy (mb.mtext, "0");
	else
	   strcpy (mb.mtext, "1");
	msgsnd(msqid, &mb, MSQSIZE, 0);
	//	printf ( "in Show Selected Sig Button\n" );
}


/*
** WorkShop Visual Stub longFormatDate
*/

void longFormatDate(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	xaxisformat = 0;
}

/*
** WorkShop Visual Stub longFormatTotal
*/

void longFormatTotal(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	xaxisformat = 1;
}

/*
** WorkShop Visual Stub longModeStand
*/

void longModeStand(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	multiple = 0;
}

/*
** WorkShop Visual Stub longModeMulti
*/

void longModeMulti(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	multiple = 1;
}

/*
** WorkShop Visual Stub longModeCopies
*/

void longModeCopies(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	multiple = -1;
}


/*
** WorkShop Visual Stub SelectTypeMenu
*/

void SelectTypeMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	graphOption = atoi(mb.mtext);
	mb.mtype = 4;
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	SetStringWidget(displayTypeText, typetext[graphOption]);
}


/*
** WorkShop Visual Stub TextfieldValue1
*/

void TextfieldValue1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	textchange = 1;
}

/*
** WorkShop Visual Stub TextfieldValue2
*/

void TextfieldValue2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	textchange = 2;
}

/*
** WorkShop Visual Stub TextfieldValue3
*/

void TextfieldValue3(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	textchange = 3;
}

/*
** WorkShop Visual Stub TextfieldValue4
*/

void TextfieldValue4(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	textchange = 4;
}

/*
** WorkShop Visual Stub TextfieldValue5
*/

void TextfieldValue5(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	textchange = 5;
}

/*
** WorkShop Visual Stub TextfieldValue6
*/

void TextfieldValue6(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	textchange = 6;
}

/*
** WorkShop Visual Stub longDeciFull
*/

void longDeciFull(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	decimation = 0;
}

/*
** WorkShop Visual Stub longDeciSec
*/

void longDeciSec(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	decimation = 1;
}

/*
** WorkShop Visual Stub longDeciMin
*/

void longDeciMin(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	decimation = 60;
}

/*
** WorkShop Visual Stub longDeciMin10
*/

void longDeciMin10(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	decimation = 10;
}

/*
** WorkShop Visual Stub longDeciHour
*/

void longDeciHour(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	decimation = 100;
}


/*
** WorkShop Visual Stub SelectModeMenu
*/

void SelectModeMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	mb.mtype = 2;
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	graphMode = atoi(mb.mtext);
  	SetStringWidget(menuModeText, modetext[graphMode]);
}



/*
** WorkShop Visual Stub TextFieldPress
*/

void TextFieldPress(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
int j;

	XmAnyCallbackStruct *call_data = (XmAnyCallbackStruct *) xt_call_data ;
	if (textchange != 0) {
	  //	  printf ( "Textfield Press: %d\n", textchange );
          switch ( textchange ) {
            case 1: 
	      strcpy ( mb.mtext, (char *)XmTextFieldGetString(yMinText) );
	      mb.mtype = 5;
	      msgsnd ( msqid, &mb, MSQSIZE, 0 );
	      if ( globOn == 0 ) {
		strcpy ( yAxisMin[chSelected], mb.mtext );
	      }
	      else {
		for ( j=0; j<16; j++ ) 
		  strcpy ( yAxisMin[j], mb.mtext );
	      }
              break;
            case 2: 
	      strcpy ( mb.mtext, (char *)XmTextFieldGetString(yMaxText) );
	      mb.mtype = 6;
	      msgsnd ( msqid, &mb, MSQSIZE, 0 );
	      if ( globOn == 0 ) {
		strcpy ( yAxisMax[chSelected], mb.mtext );
	      }
	      else {
		for ( j=0; j<16; j++ ) 
		  strcpy ( yAxisMax[j], mb.mtext );
	      }
              break;
            case 3: 
	      strcpy ( mb.mtext, (char *)XmTextFieldGetString(trigLevelText) );
	      mb.mtype = 40;
	      msgsnd ( msqid, &mb, MSQSIZE, 0 );
	      trigLev = atof(mb.mtext);
              break;
            case 4: 
	      strcpy ( mb.mtext, (char *)XmTextFieldGetString(selchan) );
	      j = atoi(mb.mtext);
	      if ( j<=0 || j>16 ) {
		printf ( "Channel %d: illegal selection\n", j );
		XmTextFieldSetString(selchan, chChange);
	      }
	      else {
		mb.mtype = 10; 
		msgsnd ( msqid, &mb, MSQSIZE, 0 );
		strcpy(chChange, mb.mtext);
	      }
              break;
            case 5: 
	      trigLev1 = atof((char *)XmTextFieldGetString(trigLevelText1));
              break;
            case 6: 
	      trigLev2 = atof((char *)XmTextFieldGetString(trigLevelText2));
              break;
            default: 
              break;
          }	  
	  textchange = 0;
	}
}

/*
** WorkShop Visual Stub SelLongSSMenu
*/

void SelLongSSMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	startstop = atoi(mb.mtext);
}


/*
** WorkShop Visual Stub SelectXAxisMenu
*/

void SelectXAxisMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  int j, resetdelay=0, tmpx, tmpdelay;
  char   tmpst[24];

	mb.mtype = 8;
	msgsnd(msqid, &mb, MSQSIZE, 0);
	tmpx = atoi(mb.mtext);
	strcpy ( xAxisScale[chSelected], mb.mtext );
	if ( globOn == 0 ) {
	  tmpdelay = atoi(xAxisDelay[chSelected]);
	  if ( tmpx >= 1 ) {
	    if ( tmpdelay>0 ) {
	      tmpdelay = 0;
	      resetdelay = 1;
	    }
	  }
	  else {
	    j = -16/tmpx;
	    if ( tmpdelay + j > 16) {
	      tmpdelay = 16 -j;
	      resetdelay = 1;
	    }
	  }
	  if (resetdelay) {
	    sprintf ( mb.mtext, "%d", tmpdelay );
	    mb.mtype = 12;
	    msgsnd(msqid, &mb, MSQSIZE, 0);
	    strcpy ( xAxisDelay[chSelected], mb.mtext );
	    //	    printf ( "Reset Ch.%d delay to %d\n", chSelected+1, tmpdelay );
	  }
	}
	else { /* global */
	  mb.mtype = 11;  /* restoring  */
	  sprintf ( mb.mtext, "%d", 1 );
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  for ( i=0; i<16; i++ ) {
	    if (i != chSelected)
	      strcpy ( xAxisScale[i], xAxisScale[chSelected] );
	    tmpdelay = atoi(xAxisDelay[i]);
	    if ( tmpx >= 1 ) {
	      if ( tmpdelay>0 ) {
		tmpdelay = 0;
		resetdelay = 1;
	      }
	    }
	    else {
	      j = -16/tmpx;
	      if ( tmpdelay + j > 16) {
		tmpdelay = 16 -j;
		resetdelay = 1;
	      }
	    }
	    if (resetdelay) {
	      mb.mtype = 9;
	      sprintf ( mb.mtext, "%d", i );
	      msgsnd ( msqid, &mb, MSQSIZE, 0 );
	      sprintf ( mb.mtext, "%d", tmpdelay );
	      mb.mtype = 12;
	      msgsnd(msqid, &mb, MSQSIZE, 0);
	      strcpy ( xAxisDelay[i], mb.mtext );
	      //	      printf ( "Reset Ch.%d delay to %d\n", i+1, tmpdelay );
	    }
	    resetdelay = 0;
	  }
	  mb.mtype = 15; /* set global */
	  sprintf ( mb.mtext, "%d", globOn );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	  mb.mtype = 11;  /* finished restoring message */
	  sprintf ( mb.mtext, "0" );
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  mb.mtype = 9;   /* reset chSelect */
	  sprintf ( mb.mtext, "%d", chSelected );
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	}
	SetStringWidget(menuDelayText, xAxisDelay[chSelected]);
	setXtext();
}


/*
** WorkShop Visual Stub SelDelayMenu
*/

void SelDelayMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
int j, tmpx, tmpdelay, resetdelay = 0;

	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	//	printf ( "called Delay\n" );
	tmpdelay = atoi(mb.mtext);
	if ( globOn == 0 ) {
	  tmpx = atoi(xAxisScale[chSelected]);
	  if ( tmpx >= 1 ) {
	    tmpdelay = 0;
	    resetdelay = 1;
	  }
	  else {
	    j = -16/tmpx;
	    if ( tmpdelay + j > 16) {
	      tmpdelay = 16 -j;
	      resetdelay = 1;
	    }
	  }
#if 0
	  if (resetdelay)
	    printf ( "Delay is too big. Reset to %d\n", tmpdelay );
#endif
	  sprintf ( xAxisDelay[chSelected], "%d", tmpdelay );
	  strcpy(mb.mtext, xAxisDelay[chSelected]);
	  mb.mtype = 12;
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	}
	else {
	  mb.mtype = 11;  /* restoring  */
	  sprintf ( mb.mtext, "1" );
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  for ( i=0; i<16; i++ ) {
	    tmpx = atoi(xAxisScale[i]);
	    if ( tmpx >= 1 ) {
	      tmpdelay = 0;
	      resetdelay = 1;
	    }
	    else {
	      j = -16/tmpx;
	      if ( tmpdelay + j > 16) {
		tmpdelay = 16 -j;
		resetdelay = 1;
	      }
	    }
#if 0
	    if (resetdelay)
	      printf ( "Delay is too big for CH.%d. Reset to %d\n", i+1, tmpdelay );
#endif
	    sprintf ( xAxisDelay[i], "%d", tmpdelay );
	    mb.mtype = 9;
	    sprintf ( mb.mtext, "%d", i );
	    msgsnd ( msqid, &mb, MSQSIZE, 0 );
	    strcpy(mb.mtext, xAxisDelay[i]);
	    mb.mtype = 12;
	    msgsnd(msqid, &mb, MSQSIZE, 0);
	    resetdelay = 0;
	  }
	  mb.mtype = 15; /* set global */
	  sprintf ( mb.mtext, "%d", globOn );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	  mb.mtype = 11;  /* finished restoring message */
	  sprintf ( mb.mtext, "0" );
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  mb.mtype = 9;   /* reset chSelect */
	  sprintf ( mb.mtext, "%d", chSelected );
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	}
	SetStringWidget(menuDelayText, xAxisDelay[chSelected]);
}


/*
** WorkShop Visual Stub unitonSel
*/

void unitonSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	if (XmToggleButtonGetState(w) == 0) {
	   strcpy ( mb.mtext, "0" );
	   if ( globOn == 0 ) 
	     eunit[chSelected] = 0;
	   else
	     for ( i=0; i<16; i++ ) eunit[i] = 0;
	}
	else {
	   strcpy ( mb.mtext, "1" );
	   if ( globOn == 0 ) 
	     eunit[chSelected] = 1;
	   else
	     for ( i=0; i<16; i++ ) eunit[i] = 1;
	}
	mb.mtype = 14;
	msgsnd(msqid, &mb, MSQSIZE, 0);
	//	printf ( "in Unit On Button\n" );
}

/*
** WorkShop Visual Stub autoYSel
*/

void autoYSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	if ( XmToggleButtonGetState(w)  == 0) {
	   strcpy ( mb.mtext, "0" );
	   if ( globOn == 0 ) 
	     autoon[chSelected] = 0;
	   else
	     for ( i=0; i<16; i++ ) autoon[i] = 0;
	}
	else {
	   strcpy ( mb.mtext, "1" );
	   if ( globOn == 0 ) 
	     autoon[chSelected] = 1;
	   else
	     for ( i=0; i<16; i++ ) autoon[i] = 1;
	}
	mb.mtype = 16;
	msgsnd(msqid, &mb, MSQSIZE, 0);
	//	printf ( "in Auto On Button\n" );
}


/*
** WorkShop Visual Stub globalonSel
*/

void globalonSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	globOn = XmToggleButtonGetState(w);
	mb.mtype = 15;  
	sprintf ( mb.mtext, "%d", globOn );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );

	/* Update all the rest of the settings */
	if (globOn) {
		autoYSel(autoOn,0,0);
		unitonSel(unitOn,0,0);
		sprintf(mb.mtext, "%s", xAxisDelay[chSelected]);
		SelDelayMenu(0,0,0);
		sprintf(mb.mtext, "%s", xAxisScale[chSelected]);
		SelectXAxisMenu(0,0,0);
		SelYTypelMenu(0,0,0);

		TextfieldValue1(0,0,0);
		TextFieldPress(0,0,0);
		TextfieldValue2(0,0,0);
		TextFieldPress(0,0,0);
	}
}

/*
** WorkShop Visual Stub SelColorMenu
*/

void SelColorMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
int j;

	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	j = atoi(mb.mtext);
	//	printf ( "Color selected %s\n", colortext[j] );
	if (j == 16) { /* default */
	  for ( i=0; i<16; i++ ) {
             gColor[i] = g0Color[i];
          }
	}
	else 
	  gColor[chSelected] = j;
	mb.mtype = 28;
	msgsnd(msqid, &mb, MSQSIZE, 0);
	SetStringWidget(menuColorText, colortext[gColor[chSelected]]);
}

/*
** WorkShop Visual Stub SelStyleMenu
*/

void SelStyleMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	linestyle = atoi(mb.mtext);
#if 0
        switch ( linestyle ) {
          case 0: 
              printf ( "Select graph style: default\n" );
              break;
          case 1: 
              printf ( "Select graph style: solid line\n" );
              break;
          case 2: 
              printf ( "Select graph style: points\n" );
              break;
        }	
#endif
}

/*
** WorkShop Visual Stub SelChDecr
*/

void SelChDecr(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmArrowButtonCallbackStruct *call_data = (XmArrowButtonCallbackStruct *) xt_call_data ;
        i = atoi(chChange) - 1;
	if (i >= 1) {
	  sprintf ( chChange, "%d", i );
	  strcpy(mb.mtext, chChange );
	  mb.mtype = 10; 
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  XmTextFieldSetString(selchan, chChange);
	}
	//	printf ( "select change ch %s\n", chChange );
}

/*
** WorkShop Visual Stub SelChIncr
*/

void SelChIncr(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmArrowButtonCallbackStruct *call_data = (XmArrowButtonCallbackStruct *) xt_call_data ;
        i = atoi(chChange) + 1;
	if (i <= 16 ) {
	  sprintf ( chChange, "%d", i );
	  strcpy(mb.mtext, chChange );
	  mb.mtype = 10; 
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  XmTextFieldSetString(selchan, chChange);
	}
	//	printf ( "select change ch %s\n", chChange );
}


/*
** WorkShop Visual Stub SelViewMenu
*/

void SelViewMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
char wfile[80];

	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	i = atoi(mb.mtext);
	if (i ==1) {
	  sprintf ( wfile, "/tmp/%slog_warning", iniDir );
	  printf ( "*******View warning file: %s*******\n", wfile );
	  if ( fork() == 0 ) {
	    if ( fork() == 0 ) {
	      execlp("tail", "tail", wfile, (char*)NULL);
	      perror("Can't read warning file");
	      exit(0);
	    }
	    else
	      exit(0);
	  }
	  else
	    wait(0);
	}
}





/*
** WorkShop Visual Stub stopLong
*/

void stopLong(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
unsigned long processID = 0;

	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;

	processID = atoi((char *)XmTextFieldGetString(lidtext));
	printf ( "Stop Long Playback ID = %ld\n", processID);
	DataSimpleConnect(serverLongIP, 0);
	DataWriteStop(processID);
	//sleep(1);
	DataQuit();
	printf ( "Long Playback: Process %ld terminated.\n", processID );
}

/*
** WorkShop Visual Stub fastSel
*/

void fastSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	fastslow = SFAST;
	ShowGroupchList(2);
	//	printf ( "Show list of fast channels\n" );
}

/*
** WorkShop Visual Stub slowSel
*/

void slowSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	fastslow = SSLOW;
	ShowGroupchList(2);
	//	printf ( "Show list of slow channels\n" );
}

/*
** WorkShop Visual Stub dmtSel
*/

void dmtSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	fastslow = SDMT;
	ShowGroupchList(2);
	//	printf ( "Show list of DMT channels\n" );
}

/*
** WorkShop Visual Stub obsoleSel
*/

void obsoleSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	fastslow = SOBS;
	ShowGroupchList(2);
	//	printf ( "Show list of Obsolete channels\n" );
}

/*
** WorkShop Visual Stub SelFrameMenu
*/

void SelFrameMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	mmSelect = atoi(mb.mtext);
	//	printf ( "Main menu select: %d\n", mmSelect );
	/* stop first */
	mb.mtype = 1;
	strcpy ( mb.mtext, "0" );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	SetStringWidget(actionText,"Stop");
	if ( saveCalled == 0 ){
	  getcwd(currentDir, sizeof(currentDir));
	  saveFileName = currentDir;
	  saveCalled = 1;
	}
	XmTextFieldSetString(savefile1,saveFileName);
	nseldir = -1;
	Ashowlist();

}

/*
** WorkShop Visual Stub filteronSel
*/

void filteronSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  short filtOn;
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	filtOn = XmToggleButtonGetState(w);
	mb.mtype = 17;  
	sprintf ( mb.mtext, "%d", filtOn );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
}

/*
** WorkShop Visual Stub saveOKSel1
*/

void saveOKSel1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
FILE *fp;
char tmpstr[100], tmpstr1[100], tmpstr2[200], tmpstr3[100];
int  tmpint, j;
char linetemp[MAX_LONG_CHANNEL_NAME_LENGTH+80];
int *position, pcount;

	strcpy ( saveFileName, (char *)XmTextFieldGetString(savefile1) );
	if ( mmSelect == MMTOC ) { /* open a toc file */
	  mmMode = 1;
	  printf ( "Openning TOC file: " );
	  sprintf ( tmpstr, "/tmp/%schannelset0", iniDir );
	  sprintf ( tmpstr1, "/tmp/%sframetime", iniDir );
	  sprintf ( tmpstr2, "%sreadtoc", origDir );
	  if ( XmListGetSelectedPos(filelist1, &position, &pcount) == 0 ) {
	    printf ( "No file is selected. Quit.\n" );
	    return;
	  }
	  else {
	    if (pcount > 1) {
	      printf ( "Error: Only one TOC file should be selected. Quit.\n" );
	      return;
	    }
	    strcpy(saveFileName, currentDir);
	    printf ( "%s\n", saveFileName );
	  }
	  free (position);

	  /* call readtoc */
	  if ( fork() == 0 ) {
	    execlp(tmpstr2,"readtoc",saveFileName,tmpstr,tmpstr1,(char*)NULL);
	    perror("Error in starting readtoc");
	    exit(0);
	  }
	  else {
	    wait(0);
	  }
	  //sleep(1);
	  /* check the status of the toc reading */
	  fp = fopen( tmpstr1, "r" );
	  if ( fp == NULL ) {
	    printf ( "Can't open file: %s\n", tmpstr1 );
	    printMessage("Error in obtaining data information", 0);
	    trend = -1;
	    return;
	  }
	  get_a_line(fp, linetemp);
	  trend = atoi(linetemp);
	  if ( trend == -1 ) {
	    printMessage("Reading failed", 0);
	    return;
	  }
	  XmTextFieldSetString(lIPtext, saveFileName );
	  XmTextFieldSetString(lPorttext, " " );
	  get_a_line(fp, linetemp);
	  fgps0 = atoi(linetemp); 
	  get_a_line(fp, linetemp);
	  fgps1 = atoi(linetemp); 
	  fclose(fp);

	  fp = fopen( tmpstr, "r" );
	  if ( fp == NULL ) {
	    printf ( "Can't open file: %s\n", tmpstr );
	    printMessage("Error in obtaining chan infomation. Please try again", 0);
	    trend = -1;
	    return;
	  }
	  get_a_line(fp, linetemp);
	  tmpint = atoi(linetemp);
	  if (tmpint == 0) {
	    printf ( "Error: 0 channel found. check the input file.\n" );
	    return;
	  }
	  if (tmpint > 16) tmpint = 16;
	  printf ( "Default %d channels:\n", tmpint);
	  for ( i=0; i<tmpint; i++ ){
	    get_a_line(fp, linetemp);
	    sscanf(linetemp, "%s %d %s %d", chName[i], &chRate[i], chUnit[i], &j );
	    printf ( "%s %d %s\n", chName[i], chRate[i], chUnit[i] );
	  }
	  fclose(fp);
	  showSig = 0;
	  DataGPStoUTC(fgps0, tmpstr);
	  printf ( "From time %s (%ld) to ", tmpstr, fgps0 );
	  DataGPStoUTC(fgps1, tmpstr);
	  printf ( "time %s (%ld)\n", tmpstr, fgps1 );
	}
	else if ( mmSelect == MMMAKETOC ) { /* make toc file */
	  XmTextFieldSetString(lIPtext, saveFileName );
	  XmTextFieldSetString(lPorttext, " " );
	  printf ( "Make TOC file from directory %s\n", saveFileName);
	  sprintf ( tmpstr, "%stocgenerate", origDir );
	  sprintf ( tmpstr1, "/tmp/%sfilter_toc", iniDir );
	  fp = fopen( tmpstr1, "w" );
	  if ( fp == NULL ) {
	    printf ( "Error: Can't open writing file: %s\n", tmpstr1 );
	    return;
	  }
	  if ( XmListGetSelectedPos(filelist1, &position, &pcount) ) {
	    fprintf ( fp, "%s\n", saveFileName );
	    for ( j=0; j<pcount; j++ ){
	      fprintf ( fp, "%s%s\n", saveFileName, fileListItem[position[j]-1] );
	    }
	  }
	  else {
	    printf ( "No file is selected. Quit.\n" );
	    fclose(fp);
	    return;
	  }
	  fclose(fp);
	  free (position);
	  printf ( "Writing all file names into %s\n", tmpstr1 );
	  /* call tocgenerate */
	  if ( fork() == 0 ) {
	    execlp(tmpstr,"tocgenerate",saveFileName,"outtoc",tmpstr1,(char*)NULL);
	    perror("Error in starting readtoc");
	    exit(0);
	  }
	  else {
	    wait(0);
	  }
	  //sleep(1);
	  printf ( "the TOC file is generated as '%souttoc'\n", currentDir);
	}
	else if ( mmSelect == MMFRAME ) { /* open frame files */
	  mmMode = 2;
	  XmTextFieldSetString(lIPtext, saveFileName );
	  XmTextFieldSetString(lPorttext, " " );
	  printf ( "Open Frame files in directory %s\n", saveFileName);
	  sprintf ( tmpstr, "%sfrgenerate", origDir );
	  sprintf ( tmpstr1, "/tmp/%schannelset0", iniDir );
	  sprintf ( tmpstr2, "/tmp/%sframetime", iniDir );
	  sprintf ( tmpstr3, "/tmp/%sfilter_fr", iniDir );
	  fp = fopen( tmpstr3, "w" );
	  if ( fp == NULL ) {
	    printf ( "Error: Can't open writing file: %s\n", tmpstr3 );
	    return;
	  }
	  if ( XmListGetSelectedPos(filelist1, &position, &pcount) ) {
	    fprintf ( fp, "%s\n", saveFileName );
	    for ( j=0; j<pcount; j++ ){
	      fprintf ( fp, "%s%s\n", saveFileName, fileListItem[position[j]-1] );
	    }
	  }
	  else {
	    printf ( "No file is selected. Quit.\n" );
	    fclose(fp);
	    return;
	  }
	  fclose(fp);
	  free (position);
	  printf ( "Writing all file names into %s\n", tmpstr3 );

	  if ( fork() == 0 ) {
	    execlp(tmpstr,"frgenerate",saveFileName,tmpstr1,tmpstr2,tmpstr3,(char*)NULL);
	    perror("Error in starting frgenerate");
	    exit(0);
	  }
	  else {
	    wait(0);
	  }
	  //sleep(1);
	  /* check the status of the toc reading */
	  fp = fopen( tmpstr2, "r" );
	  if ( fp == NULL ) {
	    printf ( "Can't open file: %s\n", tmpstr2 );
	    printMessage("Error in obtaining data information", 0);
	    trend = -1;
	    return;
	  }
	  get_a_line(fp, linetemp);
	  trend = atoi(linetemp);
	  if ( trend == -1 ) {
	    printMessage("Reading failed", 0);
	    return;
	  }
	  fclose(fp);
	  printf ( "Writting Done. Please use Playback for data display.\n");
	}
	/* load ch names etc */
	if ( mmSelect == MMFRAME || mmSelect == MMTOC ) { 
	   sprintf ( tmpstr, "/tmp/%schannelset0",  iniDir );
	   fp = fopen( tmpstr, "r" );
	   if ( fp == NULL ) {
	      printMessage("Error in obtaining chan info.", 0);
	      return;
	   }
	   get_a_line(fp, linetemp);
	   for ( i=0; i<16; i++ ){
	     get_a_line(fp, linetemp);
	     sscanf(linetemp, "%s %d %s", chName[i], &chRate[i], chUnit[i] );
	   }
	   fclose(fp);
	}
}

/*
** WorkShop Visual Stub dirlistSel1
*/

void dirlistSel1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
int *position, pcount;
char tempFileName[MAX_FILELEN];
	XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data ;
	if ( XmListGetSelectedPos(dirlist1, &position, &pcount) ) {
           nseldir = position[0]-1;
	   strcpy ( tempFileName, dirListItem[nseldir] );
	   if ( strcmp(tempFileName, "..") == 0 ) {
	      chdir("..");
	   }
	   else {
              getcwd(currentDir, sizeof(currentDir));	      
              strcat ( currentDir, "/" );
              strcat ( currentDir, tempFileName );
	      chdir(currentDir);
	   }
	   Ashowlist();
           getcwd(currentDir, sizeof(currentDir));
	   if ( strcmp(currentDir, "/") != 0 )
              strcat ( currentDir, "/" );
	   XmTextFieldSetString(savefile1, currentDir);
        }
        else
	   nseldir = -1;
	free (position);
}

/*
** WorkShop Visual Stub filelistSel1
*/

void filelistSel1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
int *position, pcount;
char tempFileName[MAX_FILELEN];
	XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data ;
	if ( XmListGetSelectedPos(filelist1, &position, &pcount) ) {
             getcwd(currentDir, sizeof(currentDir));
	     if ( strcmp(currentDir, "/") != 0 ) {
	       strcat ( currentDir, "/" );
	     }
	     if ( mmSelect == MMTOC ) {
	       strcat ( currentDir, fileListItem[position[0]-1] );
	     }
	   XmTextFieldSetString(savefile1, currentDir);
	}
	free (position);
}


/********************************************/
/********** User defined functions **********/
/********************************************/

/* show directory and file list in the file selection box  */
void Ashowlist()
{
int j;
	  XmListDeleteAllItems(dirlist1);
	  XmListDeleteAllItems(filelist1);
	AcreatList();
	  for ( j=0; j<ndirItem; j++ ){
	    XmListAddItem(dirlist1,XmStringCreateSimple(dirListItem[j]),j+1);
	  }
	  for ( j=0; j<nfileItem; j++ ){
	    XmListAddItem(filelist1,XmStringCreateSimple(fileListItem[j]),j+1);
	  }
}


/* search for directories and files for the file selection box  */
void AcreatList()
{
DIR *dirp;
struct dirent *direntp;
struct stat stbuff;

        nfileItem = 0;
	strcpy ( dirListItem[0], ".." );
	ndirItem = 1;

        dirp = opendir( "." );
        while ( (direntp = readdir( dirp )) != NULL && ndirItem<MAX_CHANNELS+100 && ndirItem<MAX_CHANNELS+100 ) {
	  if ( stat(direntp->d_name, &stbuff) != -1 && direntp->d_name[0] != '.' ) {
	     if ( (stbuff.st_mode & S_IFMT) == S_IFDIR ) {
	        strcpy ( dirListItem[ndirItem], direntp->d_name );
		ndirItem++;
	     }
	     else {
	       if (mmSelect == MMFRAME || mmSelect == MMMAKETOC || 
		   mmSelect == MMTOC || !xml_only) {
		 strcpy ( fileListItem[nfileItem], direntp->d_name );
		 nfileItem++;
	       }
	       else {
		 if ( strstr(direntp->d_name, ".xml") != NULL ) {
		   strcpy ( fileListItem[nfileItem], direntp->d_name );
		   nfileItem++;
		 }
	       }
	     }
	  }
        }
        (void)closedir( dirp );
	sortArray1(dirListItem, ndirItem);
	sortArray1(fileListItem, nfileItem);
}

void setString() 
{
  char temps[30];

  SetStringWidget(sigNamText, chName[chSelected]);
  SetStringWidget(menuDelayText, xAxisDelay[chSelected]);
  SetStringWidget(menuYScaleText, xyText[xyType[chSelected]]);
  SetStringWidget(menuColorText, colortext[gColor[chSelected]]);

  XmTextFieldSetString(yMinText, yAxisMin[chSelected]);
  XmTextFieldSetString(yMaxText, yAxisMax[chSelected]);

  if ( eunit[chSelected] ) XmToggleButtonSetState(unitOn, TRUE, TRUE);
  else XmToggleButtonSetState(unitOn, FALSE, FALSE);
  if ( autoon[chSelected] ) XmToggleButtonSetState(autoOn, TRUE, TRUE);
  else XmToggleButtonSetState(autoOn, FALSE, FALSE);
  setXtext();

  mb.mtype = 10;
  sprintf ( chChange, "%d", chSelected+1 );
  strcpy ( mb.mtext, chChange );
  msgsnd(msqid, &mb, MSQSIZE,0);
  XmTextFieldSetString(selchan, chChange);
  SetStringWidget(displayTypeText, typetext[graphOption]);
  SetStringWidget(menuModeText, modetext[graphMode]);
  SetStringWidget(displayTypeText, typetext[graphOption]);
  sprintf (temps, "%d", resolution * 128);
  SetStringWidget(menuResText, temps);
  sprintf (temps, "%d", refreshrate);
  SetStringWidget(menuRateText, temps);
}	


/*
** WorkShop Visual Stub showPage
*/

void showPage(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data ;
	switch((long)client_data) {
		case 1:
			XmProcessTraversal(connectButton, XmTRAVERSE_CURRENT);
			break;
		case 2:
			XmProcessTraversal(newDisplayButton, XmTRAVERSE_CURRENT);
			break;
		case 3:
			XmProcessTraversal(selsig, XmTRAVERSE_CURRENT);
			break;
		case 4:
			XmProcessTraversal(playbtn, XmTRAVERSE_CURRENT);
			break;
		case 5:
			XmProcessTraversal(startLong, XmTRAVERSE_CURRENT);
			break;
		default:
			break;
	}
}

/* used when starting a new Xmgr*/

updateFields() {
  char  temptext[24];
	   updateStatusField();
#if 0
	   if (chSelected == 0)
	     XmToggleButtonSetState(ch1Select, TRUE, TRUE);
#endif
	   setXtext();
  	   SetStringWidget(menuDelayText, xAxisDelay[chSelected]);
	   XmTextFieldSetString(yMinText, yAxisMin[chSelected]);
	   XmTextFieldSetString(yMaxText, yAxisMax[chSelected]);
	   SetStringWidget(sigNamText, chName[chSelected]);
  	   SetStringWidget(displayTypeText, typetext[graphOption]);
  	   SetStringWidget(menuModeText, modetext[graphMode]);
  	   sprintf (temptext, "%d", resolution*128);
  	   SetStringWidget(menuResText, temptext);
  	   sprintf (temptext, "%d", refreshrate);
  	   SetStringWidget(menuRateText, temptext);

	   /*XmToggleButtonSetState(sigOn, TRUE, TRUE);*/
	   XmToggleButtonSetState(trigOn, FALSE, FALSE);

	XmTextFieldSetString(selchan, chChange);

	SetStringWidget(menuYScaleText, xyText[xyType[chSelected]]);
	SetStringWidget(menuColorText, colortext[gColor[chSelected]]);
	if ( eunit[chSelected] ) 
	  XmToggleButtonSetState(unitOn, TRUE, TRUE);
	else
	  XmToggleButtonSetState(unitOn, FALSE, FALSE);
	if ( autoon[chSelected] ) 
	  XmToggleButtonSetState(autoOn, TRUE, TRUE);
	else
	  XmToggleButtonSetState(autoOn, FALSE, FALSE);
	sprintf (temptext, "%.2f", trigLev );
	XmTextFieldSetString(trigLevelText, temptext);
}

initializeWindows()
{
	updateFields();
	XcgTabBookSetActivePage(tabBook, 4, 0);
	showPage(0, (XtPointer)4, 0);
	LongSel(0,0,0);
	fastSel(0,0,0);
	SelTimeNow(0,0,0);
}


void initialSetting(int firsttime)
{
  int   i, irate, j;
  FILE *fp;

        //if ( firsttime ) {
	  //updateFields();
        //}
	mb.mtype = 11;  /* restoring  */
	sprintf ( mb.mtext, "1" );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	mb.mtype = 4;  /* set for GRAPHTIME */
	sprintf ( mb.mtext, "0" ); 
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	/* set windowNum and marked channels*/
	channelMarked();
	for ( i=0; i<16; i++ ) {
	   mb.mtype = 9;
	   sprintf ( mb.mtext, "%d", i );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 10;
	   sprintf ( mb.mtext, "%d", i+1 );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 3;
	   strcpy ( mb.mtext, chName[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 13;
	   strcpy ( mb.mtext, chUnit[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 5;
	   strcpy ( mb.mtext, yAxisMin[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 6;
	   strcpy ( mb.mtext, yAxisMax[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 7;
	   sprintf ( mb.mtext, "%d", xyType[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 14;
	   sprintf ( mb.mtext, "%d", eunit[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 16;
	   sprintf ( mb.mtext, "%d", autoon[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 8;
	   sprintf ( mb.mtext, "%s", xAxisScale[i] );
	   msgsnd ( msqid, &mb, MSQSIZE, 0 );
	   mb.mtype = 12;
	   sprintf ( mb.mtext, "%s", xAxisDelay[i] );
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	   /* set color selection */
	   mb.mtype = 28; 
	   sprintf ( mb.mtext, "%d", gColor[i] );
	   msgsnd(msqid, &mb, MSQSIZE, 0);
	}
	mb.mtype = 48;  /* set sigOn */
	sprintf ( mb.mtext, "%d", XmToggleButtonGetState(sigOn) );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	mb.mtype = 25; /* set for Resolution */
	sprintf ( mb.mtext, "%d", resolution );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	mb.mtype = 26; /* set for Refresh Rate */
	sprintf ( mb.mtext, "%d", refreshrate );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	mb.mtype = 4;  /* set graph option */
	sprintf ( mb.mtext, "%d", graphOption ); 
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	mb.mtype = 2;  /* set graph method */
	sprintf ( mb.mtext, "%d", graphMode ); 
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	mb.mtype = 15; /* set global */ 
	sprintf ( mb.mtext, "%d", globOn );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	mb.mtype = 9;  /* set selected channel */
	sprintf ( mb.mtext, "%d", chSelected ); 
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
	mb.mtype = 10;  
	strcpy(mb.mtext, chChange);
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
#if 0
	XmTextFieldSetString(selchan, chChange);

	SetStringWidget(menuYScaleText, xyText[xyType[chSelected]]);
	SetStringWidget(menuColorText, colortext[gColor[chSelected]]);
	if ( eunit[chSelected] ) 
	  XmToggleButtonSetState(unitOn, TRUE, TRUE);
	else
	  XmToggleButtonSetState(unitOn, FALSE, FALSE);
	if ( autoon[chSelected] ) 
	  XmToggleButtonSetState(autoOn, TRUE, TRUE);
	else
	  XmToggleButtonSetState(autoOn, FALSE, FALSE);
#endif

	/* set trigger */
	mb.mtype = 36;
	sprintf ( mb.mtext, "%d", XmToggleButtonGetState(trigOn) );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	mb.mtype = 37;
	sprintf ( mb.mtext, "%d", chanTrig );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	mb.mtype = 39;
	sprintf ( mb.mtext, "%d", trigHow );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	mb.mtype = 40;
	sprintf ( mb.mtext, "%.2f", trigLev );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	//XmTextFieldSetString(trigLevelText, mb.mtext);

	mb.mtype = 15; /* set global */
	sprintf ( mb.mtext, "%d", globOn );
	msgsnd(msqid, &mb, MSQSIZE, 0);
	mb.mtype = 11;  /* finished restoring  */
	sprintf ( mb.mtext, "0" );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
#if 0
	mb.mtype = 9;   /* reset chSelect */
	sprintf ( mb.mtext, "%d", chSelected );
	msgsnd ( msqid, &mb, MSQSIZE, 0 );
#endif

}


/* reset signal list in alphabetic (abc=1) or original order (abc=0) */
void resetSigList(int abc)
{
char linetemp[MAX_LONG_CHANNEL_NAME_LENGTH+80], tempname[80], tempst[100];
char tempArray[MAX_LONG_CHANNEL_NAME_LENGTH+1], tempUnit[MAX_LONG_CHANNEL_NAME_LENGTH+1];
int  tempRate, j;
int  group, rate, counter;
FILE *fp;

        //printf ( "Arranging %d signals...\n", sigCounter ); 
        if ( abc ) { 
	   for ( i=1; i<sigCounter; i++ ) {
	      for ( j=i+1; j<=sigCounter; j++) {
		if ( strcmp(sigListItem[i], sigListItem[j])>0 ){
		  strcpy ( tempArray, sigListItem[i] );
		  strcpy ( sigListItem[i], sigListItem[j] );
		  strcpy ( sigListItem[j], tempArray );
		  tempRate = sigListRate[i];
		  sigListRate[i] = sigListRate[j];
		  sigListRate[j] = tempRate;
		}
	      }
	   }
	}
	//qsort(sigListItem, sigCounter, sizeof(sigListItem[0]), strcmp);
	//        printf ( "Done.\n" ); 
	/* restting */
	XmListDeleteAllItems(siglist);
	//XmTextFieldSetString(selsig, " ");
        for ( i=0; i<sigCounter; i++ ) {
	  sigListItemString[i] = XmStringCreateSimple(sigListItem[i+1]);
	}
	XmListAddItems(siglist,sigListItemString,sigCounter,1);
        for ( i=0; i<sigCounter; i++ ) XmStringFree(sigListItemString[i]);
}


void setDecimation() 
{
int  duration;
char temptext[4];
 
      if (mmMode) { /* frame */
	if ( trend == 0 ) {
	   decimation = 0;
	   XmToggleButtonSetState(lfull, TRUE, TRUE);
	   //	   printf ( "Full data file.\n" );
	}
	else if ( trend == 1 ) {
	   decimation = 1;
	   XmToggleButtonSetState(lsec, TRUE, TRUE);
	   //	   printf ( "Second trend data file.\n" );
	}
	else if ( trend == 60 ) {
	   decimation = 60;
	   XmToggleButtonSetState(lmin1, TRUE, TRUE);
	   //	   printf ( "Minute trend data file.\n" );
	}
      }
      else {
	/* get timer */
	strcpy( temptext, (char *)XmTextFieldGetString(refTimeDay));
	totalPlay.days = atoi(temptext);
	strcpy( temptext, (char *)XmTextFieldGetString(refTimeHr));
	totalPlay.hours = atoi(temptext);
	strcpy( temptext, (char *)XmTextFieldGetString(refTimeMin));
	totalPlay.mins = atoi(temptext);
	strcpy( temptext, (char *)XmTextFieldGetString(refTimeSec));
	totalPlay.secs = atoi(temptext);
	duration = (totalPlay.days*24 + totalPlay.hours)*3600 + totalPlay.mins*60 + totalPlay.secs;
	if ( duration == 0 ) { 
	   decimation = 60;
	   XmToggleButtonSetState(lmin1, TRUE, TRUE);
	}
	else if ( duration <= 10 ) { 
	   decimation = 0;
	   XmToggleButtonSetState(lfull, TRUE, TRUE);
	}
	else if ( duration <= 3600 ) { /* 1 hour */
	   decimation = 1;
	   XmToggleButtonSetState(lsec, TRUE, TRUE);
	}
	else if ( duration <= 216000 ) { /* 60 hours */
	   decimation = 60;
	   XmToggleButtonSetState(lmin1, TRUE, TRUE);
	}
	else if ( duration <= 2592000 ) { /* 30 days */
	   decimation = 10;
	   XmToggleButtonSetState(lmin10, TRUE, TRUE);
	}
	else  { /* > 30 days */
	   decimation = 100;
	   XmToggleButtonSetState(lhr, TRUE, TRUE);
	}
      }
      return;
}

void ShowGroupchList(int reload)
{
char tempstring[MAX_LONG_CHANNEL_NAME_LENGTH+24];

	if ( reload  || showSig ==0) {
	   for ( i=0; i<MAX_CHANNEL_GROUPS; i++ ){
	     openTop[i] = 0;  /* all top level closed */
	   }
	   XmListDeleteAllItems(grouplist);
	   XmListDeleteAllItems(siglist);
	   //XmTextFieldSetString(selsig, " ");

	   writeChannelset(reload); 

	   for ( i=0; i<topTotal; i++ ){
	      strcpy( groupList[i+1], topGroup[i] );
	      XmListAddItem(grouplist,XmStringCreateSimple(groupList[i+1]), i+1);
	   }
	   showSig =1;
	}
        for (i = 0; i < 16; i++) {
          Widget vees [16] = {v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16};
	  sprintf (tempstring, "%d: %s", i+1, chName[i]);
          XmTextFieldSetString(vees[i], "");
	  XmTextFieldSetString(vees[i], tempstring );
	}
}


void startXmgr(int play) 
{
int   i;
FILE *fp;
key_t MSQKEY;
char  displaystring[MAX_FILELEN], tempstring[100];

	   XmToggleButtonSetState(filterOn, FALSE, FALSE);
           sscanf (iniDir, "%dDC/", &i);
	   MSQKEY = i;    /*rand();*/
	   
	   sprintf ( displaystring, "%sframer%d %d %s %d %s %s /tmp/%s %s %s %d %d", origDir, plotterNum,  MSQKEY, serverIP, serverPort, origDir, displayIP, iniDir, version_n, version_y, zoomflag, nolimit );
	   sprintf ( tempstring, "/tmp/%sstartDisplay", iniDir );
	   fp = fopen(tempstring, "w");
	   if (fp == NULL) {
	      printMessage("Fatal error occured in starting Xmgrace. Can't open writing file. Please exit and restart", 0);
	      return;
	   }
	   fprintf ( fp, "mkdir /tmp/$$FRAME\n" );
	   fprintf ( fp, "%s $$\n", displaystring );
	   fprintf ( fp, "/bin/rm -f -r /tmp/$$FRAME\n" );
	   fclose(fp);
	   //fprintf ( stderr, "START: %s\n", displaystring );
	   //sleep(2);

	   if ( fproc1 ) kill(fproc1, SIGKILL);
	   fproc1 = fork();
	   //printf ( "Fproc = %d\n", fproc1 );
	   if ( fproc1 == 0 ) {
	     if ( fork() == 0 ) {
	       //fprintf ( stderr, "Child executing shell\n" );
	       args[0] = "bash";
	       sprintf ( tempstring, "/tmp/%sstartDisplay", iniDir );
	       free(args[1]);
	       args[1] =  (char *) malloc(500*sizeof(char));
	       strcpy(args[1], tempstring);
	       /*args[1] = "/spa1/code/v2.3/sun/bin/stestDisplay";*/ 
	       args[2] = NULL;
	       execv("/bin/bash",args);
	       perror("Fork error");
	       exit(0);
	     }
	     else
	       exit(0);
	   }
	   else
	     wait(0);
	   if ( (msqid = msgget(MSQKEY,IPC_CREAT | 0666)) < 0 ) {
	      perror("msgget");
	      //sleep(4);
	      exit(1);
	   }
	   //sprintf ( tempstring,"control: attached message que %d to %d", MSQKEY, msqid );
	   //printMessage(tempstring, 0);
	   //sleep(3);

	   /*** set initial values ***/
	   initialSetting(firstTime);
	   firstTime = 0;

	   if ( play ) { /* start realtime */
	     //sleep(3);
	     mb.mtype = 1;
	     strcpy ( mb.mtext, "2" );
	     msgsnd(msqid, &mb, MSQSIZE, 0);
	   }
}


void setXtext()
{
  extern Widget menuXScaleText;
  int j = atoi(xAxisScale[chSelected]);
  if (j > 0) sprintf ( xShowText,"%d", j, xUnit);
  else sprintf ( xShowText,"1/%d", -j, xUnit);
  SetStringWidget(menuXScaleText, xShowText);
}


void sortArray1(char listArray[MAX_CHANNELS+100][MAX_FILELEN], int arraySize)
{
char tempArray[MAX_FILELEN];
int j;

        for ( i=0; i<arraySize-1; i++ ) {
	   for ( j=i+1; j<arraySize; j++) {
	      if ( strcmp(listArray[i], listArray[j])>0 ){
		 strcpy ( tempArray, listArray[i] );
		 strcpy ( listArray[i], listArray[j] );
		 strcpy ( listArray[j], tempArray );
	      }
	   }
        }
}

void sortArray(char listArray[MAX_CHANNEL_GROUPS][MAX_LONG_CHANNEL_NAME_LENGTH+1], int arraySize)
{
char tempArray[MAX_LONG_CHANNEL_NAME_LENGTH+1];
int j;

        for ( i=0; i<arraySize-1; i++ ) {
	   for ( j=i+1; j<arraySize; j++) {
	      if ( strcmp(listArray[i], listArray[j])>0 ){
		 strcpy ( tempArray, listArray[i] );
		 strcpy ( listArray[i], listArray[j] );
		 strcpy ( listArray[j], tempArray );
	      }
	   }
        }
}

void get_a_line(FILE* read_file, char s[])
{ 
int j;
 
  fgets(s, MAX_LONG_CHANNEL_NAME_LENGTH+79, read_file);
  j = strlen(s);
  s[j] = '\0';
  return;
}


/* returns 0 if sub is a substring of s starting from the beginning */
int test_substring (char sub[], char s[])
{
int len, j;

  len = strlen(sub);
  if (len > strlen(s))  return 1;
  for ( j=0; j<len; j++ ) {
    if (sub[j] != s[j]) return 1;
  }
  return 0;
}

/* chop off the part after the char, returns 1 if the char not found */
int chop_string (char inout[], char sep)
{
int len, j;
  
  len = strlen(inout);
  for ( j=0; j<len; j++ ) {
    if (inout[j] == sep) {
      inout[j] = '\0';
      return 0;
    }
  }
  return 1;
}

/* for save-restore */
void get_save_line(FILE* read_file, char s[])
{ int i=0;
  fgets(s, 400, read_file);
  while (s[i] != '\n') i++;
  s[i] = '\0';
  return;
}

/* get the part of the string between char a and b */
int string_chop(char sout[], char sin[], char a, char b)
{
int i, i1=-1, i2=-1;
  for ( i=0; i<strlen(sin); i++ ) {
    if (sin[i] == a) {
      i1 = i+1;
      break;
    }
  } 
  for ( i=0; i<strlen(sin); i++ ) {
    if (sin[i] == b) {
      i2 = i-1;
      break;
    }
  } 
  if (i1<0 || i2<0 || i1> i2)
    return -1;
  for ( i=0; i<i2-i1+1; i++ ) {
    sout[i] = sin[i+i1];
  } 
  sout[i2-i1+1] = '\0';
  return i2-i1+1;
}

void
populate_3rd_lvl_chgrp(char *chtemp) {
      int i, found;
      char s[MAX_LONG_CHANNEL_NAME_LENGTH+24];
      strcpy(s, chtemp);
      chop_string(s, '_');
      strcat(s,"_");
      for (i = 0, found = 0; i < ttlgrp3rd; i++) {
	if (!strcmp(thirdGroup[i], s)) { found = 1; break; }
      }
      if (!found){
	      //printf("3rd level group %s\n", s);
	      strcpy(thirdGroup[ttlgrp3rd++], s);
      }
}



void writeChannelset(int reload)
{
int  rate, counter, j, k, totalchan_temp;
short yes;
char groupname[MAX_LONG_CHANNEL_NAME_LENGTH+3], chtemp[MAX_LONG_CHANNEL_NAME_LENGTH+8],tempname[80],tempstring[MAX_LONG_CHANNEL_NAME_LENGTH+24],linetemp[MAX_LONG_CHANNEL_NAME_LENGTH+80];
FILE *fp, *fq;

	   /* sort all channels for group names */
           if (fastslow == SDMT)
	     sprintf ( tempname, "/tmp/%schannelset_dmt",  iniDir );
           else if (fastslow == SOBS)
	     sprintf ( tempname, "/tmp/%schannelset_obs",  iniDir );
	   else
	     sprintf ( tempname, "/tmp/%schannelset0",  iniDir );
	   fq = fopen( tempname, "r" );
	   if ( fq == NULL ) {
	      printMessage("Error in obtaining chan info.", 0);
	      return;
	   }
	   /* get top level names */
	   get_a_line(fq, linetemp);
	   totalchan = atoi(linetemp);
	   //printf ( "%d channels found.\n", totalchan );
	   topTotal = 0;
	   totalgroup = 0;
	   totalchan_temp = 0;
	   for ( i=0; i<totalchan; i++ ){
	     get_a_line(fq, linetemp);
	     sscanf(linetemp, "%s %d %s", chtemp, &rate, tempstring );
	     /* load first 16 channels */
	     if ( reload==1 && i < 16 ) {
	       strcpy(chName[i], chtemp);
	       strcpy(chUnit[i], tempstring);
               chRate[i] = rate; 
             }
	     if ( fastslow == SDMT || fastslow == SOBS)
	       yes = 1;
	     else if ( fastslow == SFAST && rate > 16 )
	       yes = 1;
	     else if ( fastslow == SSLOW && rate <= 16 )
	       yes = 1;
	     else
	       yes = 0;
	     if ( yes ) {
	       chop_string(chtemp, ':');
	       strcpy(linetemp, chtemp);
	       k = chop_string(chtemp, '-');
	       if ( topTotal == 0 ) {
		 strcpy(topGroup[topTotal], chtemp);
		 topTotal ++;
	       }
	       else {
		 counter = 0; 
		 for ( j=0; j<topTotal; j++ ){
		   if ( strcmp(topGroup[j], chtemp ) == 0 ) {
		     counter = 1;
		     break;
		   }
		 }
		 if ( counter == 0 ) {
		   strcpy(topGroup[topTotal], chtemp);
		   topTotal ++;
		 }
	       }	     
	       if ( k == 0 ) { /* vacuum chan top level */
		 if ( totalgroup == 0 ) {
		   strcpy(secGroup[totalgroup], linetemp);
		   totalgroup ++;
		 }
		 else {
		   counter = 0; 
		   for ( j=0; j<totalgroup; j++ ){
		     if ( strcmp(secGroup[j], linetemp ) == 0 ) {
		       counter = 1;
		       break;
		     }
		   }
		   if ( counter == 0 ) {
		     strcpy(secGroup[totalgroup], linetemp);
		     totalgroup ++;
		   }
		 }	     
	       }
	     }
	   }
	   sortArray(topGroup, topTotal);
	   ttlgrp3rd = 0;

	   /* get all group names */
	   fseek(fq, 0, 0); /* reset the reading file stream */
	   get_a_line(fq, linetemp);
	   for ( i=0; i<totalchan; i++ ){
	     get_a_line(fq, linetemp);
	     sscanf(linetemp, "%s %d %s", chtemp, &rate, tempstring );
	     if ( fastslow == SDMT || fastslow == SOBS )
	       yes = 1;
	     else if ( fastslow == SFAST && rate > 16 )
	       yes = 1;
	     else if ( fastslow == SSLOW && rate <= 16 )
	       yes = 1;
	     else
	       yes = 0;
	     if ( yes ) {
	       totalchan_temp++;
	       populate_3rd_lvl_chgrp(chtemp);
	       chop_string(chtemp, '-');
	       strcpy(linetemp, chtemp);
	       if ( chop_string(linetemp, ':') == 0 ) { /* if ':' presents */
		   counter = 0; 
		   for ( j=0; j<totalgroup; j++ ){
		     if ( strcmp(secGroup[j], chtemp ) == 0 ) {
		       counter = 1;
		       break;
		     }
		   }
		   if ( counter == 0 ) {
		     //printf("Second level channel group %s\n", chtemp);
		     strcpy(secGroup[totalgroup], chtemp);
		     totalgroup ++;
		   }
	       }
	     }    
	   }
	   sortArray(secGroup, totalgroup);
	   sortArray(thirdGroup, ttlgrp3rd);
	   fseek(fq, 0, 0); /* reset the reading file stream */

	   /* write file channelset */
	   sprintf ( tempname, "/tmp/%schannelset",  iniDir );
	   fp = fopen( tempname, "w" );
	   if ( fp == NULL ) {
	      printMessage("Can't write channelset file.", 0);
	      return;
	   }
	   fprintf ( fp, "%d\n", topTotal);
	   for ( i=0; i<topTotal; i++ )
	     fprintf ( fp, "%s\n", topGroup[i]);
	   fprintf ( fp, "%d\n", totalgroup);
	   for ( i=0; i<totalgroup; i++ )
	     fprintf ( fp, "%s\n", secGroup[i]);
	   fprintf ( fp, "%d\n", ttlgrp3rd);
	   for ( i=0; i<ttlgrp3rd; i++ )
	     fprintf ( fp, "%s\n", thirdGroup[i]);
	   get_a_line(fq, linetemp); /* skip */
	   fprintf ( fp, "%d\n", totalchan_temp);
	   for ( i=0; i<totalchan; i++ ) {
	     get_a_line(fq, linetemp);
	     if (strlen(linetemp) > 0) {
	       sscanf(linetemp, "%s %d %s", chtemp, &rate, tempstring );
	       if ( fastslow == SDMT || fastslow == SOBS )
		 yes = 1;
	       else if ( fastslow == SFAST && rate > 16 )
		 yes = 1;
	       else if ( fastslow == SSLOW && rate <= 16 )
		 yes = 1;
	       else
		 yes = 0;
	       if ( yes ) 
		 fprintf ( fp, "%s", linetemp);
	     }
	   }
	   fclose(fp);
	   fclose(fq);
	   totalchan = totalchan_temp;
	   return;
}

/******************** END OF USER DEFINED FUNCTIONS  ********************/


/* de=0 always print. de=1 depends on debug */
void printMessage(char msg[], int de) 
{
        if (de == 0)
	  printf ( "%s\n", msg );
	else if ( debug) {
	  printf ( "%s\n", msg );
	}

}


/*
** WorkShop Visual Stub multiSel
*/

void multiSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  chMarked [(long)client_data] = XmToggleButtonGetState (w);
  channelMarked();
}

void channelMarked()
{
  int i;
  char chstring[MSQSIZE], tempst[64];

  windowNum = 0;
  strcpy(chstring, " ");
  for ( i=0; i<16; i++ ) {
    sprintf ( tempst,"%d ", i );
    if (chMarked[i]) {
      windowNum++;
      strcat(chstring, tempst);
    }
  }

  /*printf ( "Total %d channels: %s\n", windowNum, chstring );*/ 
  if (!windowNum) stopButton(0,0,0); // Stop running
  else {
    for ( i=windowNum; i<16; i++ ) strcat(chstring, "0 ");
    mb.mtype = 24;
    sprintf ( mb.mtext, "%d %s", windowNum, chstring ); 
    msgsnd(msqid, &mb, MSQSIZE, 0);
  }
}


/* Used at the option -r restorefilename */
void restore_File(char restorefilename[])
{
  FILE *fp;
  char tmpstr[400], templine[200], term1[200], term2[200], nametag[80];
  int  tmpint, chtag;

  saveFileName = restorefilename;
  restoreFile = 0;
  saveCalled = 1;
  printf ( "Restoring settings from the file %s\n", saveFileName );

  mb.mtype = 11;  /* restoring  */
  sprintf ( mb.mtext, "1" );
  msgsnd ( msqid, &mb, MSQSIZE, 0 );
  fp = fopen(saveFileName, "r");
  if ( fp == NULL ) {
    sprintf ( tmpstr, "Can't open reading file: %s", saveFileName );
    printMessage(tmpstr, 0);
    return;
  }
  else {
    sprintf ( tmpstr, "reading file: %s", saveFileName );
    printMessage(tmpstr, 0);
  }

  get_save_line(fp, tmpstr);
  if (strncmp(tmpstr, "<?xml", 5) != 0) {
    sprintf ( tmpstr, "Error: %s was saved by an older version of Dataviewer (earlier than V9.0). Please convert the file first. See Help->About.", saveFileName);
    printMessage(tmpstr, 0);
    return;
  }

  /* read and process the restore file  */
  while (1) {
    get_save_line(fp, templine);
    if (strcmp(templine, "</DATAVIEWER>") == 0  ) {
      break;
    }
    if (strchr(templine, '/') != NULL) {
      /* process the line  */
      if (string_chop(term1, templine, '<', '>') > 0) {
	if (strstr(term1, "=") != NULL) {
	  sscanf (term1, "%s ch=\"%d%s", nametag, &chtag, term2 );
	}
	else
	  strcpy ( nametag, term1);
      }
      templine[0] = '0';
      if (string_chop(term1, templine, '>', '<') > 0) { /* date is not empty  */
	if (strcmp( nametag, "VERSION") == 0) {
	  if (term1[0] != version_n[0]) {
	    sprintf ( tmpstr, "Warning: %s was saved by Dataviewer version %s and you're now running version %s. You may need to convert the file first. See Help->About for help", saveFileName, term1, version_n );
	    printMessage(tmpstr, 0);
	  }
	}
	else if (strcmp( nametag, "CHANNO") == 0) {
	  windowNum = atoi(term1);
	}
	else if (strcmp( nametag, "NAME") == 0) {
	  strcpy(chName[chtag-1], term1);
	  sprintf ( tmpstr, "restoring Ch %d Name = %s", chtag, chName[chtag-1] );
	  printMessage(tmpstr, 0);
	}
	else if (strcmp( nametag, "RATE") == 0) {
	  chRate[chtag-1]= atoi(term1);
	}
	else if (strcmp( nametag, "UNIT") == 0) {
	  strcpy(chUnit[chtag-1], term1);
	}	 
	else if (strcmp( nametag, "YMIN") == 0) {
	  strcpy(yAxisMin[chtag-1], term1);
	}
	else if (strcmp( nametag, "YMAX") == 0) {
	  strcpy(yAxisMax[chtag-1], term1);
	}
	else if (strcmp( nametag, "XSCALE") == 0) {
	  strcpy(xAxisScale[chtag-1], term1);
	}
	else if (strcmp( nametag, "XDELAY") == 0) {
	  strcpy(xAxisDelay[chtag-1], term1);
	}
	else if (strcmp( nametag, "XYTYPE") == 0) {
	  xyType[chtag-1]= atoi(term1);
	}
	else if (strcmp( nametag, "EUNIT") == 0) {
	  eunit[chtag-1]= atoi(term1);
	}
	else if (strcmp( nametag, "AUTO") == 0) {
	  autoon[chtag-1]= atoi(term1);
	}
	else if (strcmp( nametag, "COLOR") == 0) {
	  gColor[chtag-1]= atoi(term1);
	}
	else if (strcmp( nametag, "GRAPHOPTION") == 0) {
	  graphOption = atoi(term1);
	}
	else if (strcmp( nametag, "GRAPHMODE") == 0) {
	  graphMode = atoi(term1);
	}
	else if (strcmp( nametag, "CHSELECTED") == 0) {
	  chSelected = atoi(term1);
	}
	else if (strcmp( nametag, "GLOBAL") == 0) {
	  globOn = atoi(term1);
	  XmToggleButtonSetState(globalOn, globOn, globOn);
	}
	else if (strcmp( nametag, "TRIGGER") == 0) {
	  /* set trigger */
	  mb.mtype = 36;  
	  tmpint = atoi(term1);
	  sprintf ( mb.mtext, "%d", tmpint );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	  XmToggleButtonSetState(trigOn, tmpint, tmpint);
	  mb.mtype = 37;
	  chanTrig = chtag;
	  sprintf ( mb.mtext, "%d", chanTrig );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	}
	else if (strcmp( nametag, "TRIGGERLEV") == 0) {
	  trigLev = atof(term1);
	  mb.mtype = 40;
	  sprintf ( mb.mtext, "%.2f", trigLev );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	  XmTextFieldSetString(trigLevelText, mb.mtext);
	}	 
	else if (strcmp( nametag, "SIGON") == 0) {
	  tmpint = atoi(term1);
	  mb.mtype = 48;  /* set sigOn */
	  sprintf ( mb.mtext, "%d", tmpint );
	  msgsnd(msqid, &mb, MSQSIZE, 0);
	  XmToggleButtonSetState(sigOn, tmpint, tmpint);
	}
	else if (strcmp( nametag, "RESOLUTION") == 0) {
	  resolution = atoi(term1);
	  mb.mtype = 25;  /* set resolution */
	  sprintf ( mb.mtext, "%d", resolution); 
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  SetStringWidget(menuResText, mb.mtext);
	}
	else if (strcmp( nametag, "REFRESHRATE") == 0) {
	  refreshrate = atoi(term1);
	  mb.mtype = 26;  /* set refreshrate */
	  sprintf ( mb.mtext, "%d", refreshrate); 
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  SetStringWidget(menuRateText, mb.mtext);
	}
	else if (strcmp( nametag, "FILTER") == 0) {
	  tmpint = atoi(term1);
	  mb.mtype = 17;  /* set filterOn */
	  sprintf ( mb.mtext, "%d", tmpint ); 
	  msgsnd ( msqid, &mb, MSQSIZE, 0 );
	  XmToggleButtonSetState(filterOn, tmpint, tmpint);
	}
	else if (strcmp( nametag, "CHMARKED") == 0) {
	  /* set no. of chans and marked channels*/
	  sscanf ( term1, "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d", &chMarked[0], &chMarked[1], &chMarked[2], &chMarked[3], &chMarked[4], &chMarked[5], &chMarked[6], &chMarked[7], &chMarked[8], &chMarked[9], &chMarked[10], &chMarked[11], &chMarked[12], &chMarked[13], &chMarked[14], &chMarked[15] );
	  channelMarked();
	}
      }
    }
  }
  /* end of reading restore file  */

  fclose(fp);

  mb.mtype = 4;  
  sprintf ( mb.mtext, "%d", graphOption );
  msgsnd ( msqid, &mb, MSQSIZE, 0 );
  for ( i=0; i<16; i++ ) {
    mb.mtype = 10;
    sprintf ( mb.mtext, "%d", i+1 );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 3;
    strcpy ( mb.mtext, chName[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 13;
    strcpy ( mb.mtext, chUnit[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 9;
    sprintf ( mb.mtext, "%d", i );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 5;
    strcpy ( mb.mtext, yAxisMin[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 6;
    strcpy ( mb.mtext, yAxisMax[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 7;
    sprintf ( mb.mtext, "%d", xyType[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 14;
    sprintf ( mb.mtext, "%d", eunit[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 16;
    sprintf ( mb.mtext, "%d", autoon[i] );
    msgsnd ( msqid, &mb, MSQSIZE, 0 );
    mb.mtype = 8; 
    strcpy ( mb.mtext, xAxisScale[i] );
    msgsnd(msqid, &mb, MSQSIZE, 0);
    mb.mtype = 12; 
    strcpy ( mb.mtext, xAxisDelay[i] );
    msgsnd(msqid, &mb, MSQSIZE, 0);
    mb.mtype = 28; 
    sprintf ( mb.mtext, "%d", gColor[i] );
    msgsnd(msqid, &mb, MSQSIZE, 0);
  }
  mb.mtype = 2;  /* set graph method */
  sprintf ( mb.mtext, "%d", graphMode ); 
  msgsnd ( msqid, &mb, MSQSIZE, 0 );
  mb.mtype = 15; /* set global */
  sprintf ( mb.mtext, "%d", globOn );
  msgsnd(msqid, &mb, MSQSIZE, 0);

  mb.mtype = 11;  /* finished restoring message */
  sprintf ( mb.mtext, "0" );
  msgsnd ( msqid, &mb, MSQSIZE, 0 );
  mb.mtype = 9;   /* reset chSelect */
  sprintf ( mb.mtext, "%d", chSelected );
  msgsnd ( msqid, &mb, MSQSIZE, 0 );

  for ( i=0; i<16; i++ ) {
    if ( chMarked[i] )
      switch ( i ) {
      case 0: 
	XmToggleButtonSetState(ch1Select, TRUE, TRUE);
	break;
      case 1: 
	XmToggleButtonSetState(ch2Select, TRUE, TRUE);
	break;
      case 2: 
	XmToggleButtonSetState(ch3Select, TRUE, TRUE);
	break;
      case 3: 
	XmToggleButtonSetState(ch4Select, TRUE, TRUE);
	break;
      case 4: 
	XmToggleButtonSetState(ch5Select, TRUE, TRUE);
	break;
      case 5: 
	XmToggleButtonSetState(ch6Select, TRUE, TRUE);
	break;
      case 6: 
	XmToggleButtonSetState(ch7Select, TRUE, TRUE);
	break;
      case 7: 
	XmToggleButtonSetState(ch8Select, TRUE, TRUE);
	break;
      case 8: 
	XmToggleButtonSetState(ch9Select, TRUE, TRUE);
	break;
      case 9: 
	XmToggleButtonSetState(ch10Select, TRUE, TRUE);
	break;
      case 10: 
	XmToggleButtonSetState(ch11Select, TRUE, TRUE);
	break;
      case 11: 
	XmToggleButtonSetState(ch12Select, TRUE, TRUE);
	break;
      case 12: 
	XmToggleButtonSetState(ch13Select, TRUE, TRUE);
	break;
      case 13: 
	XmToggleButtonSetState(ch14Select, TRUE, TRUE);
	break;
      case 14: 
	XmToggleButtonSetState(ch15Select, TRUE, TRUE);
	break;
      case 15: 
	XmToggleButtonSetState(ch16Select, TRUE, TRUE);
	break;
      }	
    else
      switch ( i ) {
      case 0: 
	XmToggleButtonSetState(ch1Select, FALSE, FALSE);
	break;
      case 1: 
	XmToggleButtonSetState(ch2Select, FALSE, FALSE);
	break;
      case 2: 
	XmToggleButtonSetState(ch3Select, FALSE, FALSE);
	break;
      case 3: 
	XmToggleButtonSetState(ch4Select, FALSE, FALSE);
	break;
      case 4: 
	XmToggleButtonSetState(ch5Select, FALSE, FALSE);
	break;
      case 5: 
	XmToggleButtonSetState(ch6Select, FALSE, FALSE);
	break;
      case 6: 
	XmToggleButtonSetState(ch7Select, FALSE, FALSE);
	break;
      case 7: 
	XmToggleButtonSetState(ch8Select, FALSE, FALSE);
	break;
      case 8: 
	XmToggleButtonSetState(ch9Select, FALSE, FALSE);
	break;
      case 9: 
	XmToggleButtonSetState(ch10Select, FALSE, FALSE);
	break;
      case 10: 
	XmToggleButtonSetState(ch11Select, FALSE, FALSE);
	break;
      case 11: 
	XmToggleButtonSetState(ch12Select, FALSE, FALSE);
	break;
      case 12: 
	XmToggleButtonSetState(ch13Select, FALSE, FALSE);
	break;
      case 13: 
	XmToggleButtonSetState(ch14Select, FALSE, FALSE);
	break;
      case 14: 
	XmToggleButtonSetState(ch15Select, FALSE, FALSE);
	break;
      case 15: 
	XmToggleButtonSetState(ch16Select, FALSE, FALSE);
	break;
      }	   
  }	   

  SetStringWidget(sigNamText, chName[chSelected]);
  SetStringWidget(menuYScaleText, xyText[xyType[chSelected]]);
  ShowGroupchList(0);
  setString();

  return;
}

/*
** WorkShop Visual Stub SelTrigLongMenu1
*/

void SelTrigLongMenu1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	chanTrig1 = atoi(mb.mtext);
}

/*
** WorkShop Visual Stub SelTrigAboveLongMenu1
*/

void SelTrigAboveLongMenu1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	trigHow1 = atoi(mb.mtext);
}

/*
** WorkShop Visual Stub SelTrigLongMenu2
*/

void SelTrigLongMenu2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	chanTrig2 = atoi(mb.mtext);
}

/*
** WorkShop Visual Stub SelTrigAboveLongMenu2
*/

void SelTrigAboveLongMenu2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	trigHow2 = atoi(mb.mtext);
}


/*
** WorkShop Visual Stub SelTrigAndOrLongMenu
*/

void SelTrigAndOrLongMenu(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmRowColumnCallbackStruct *call_data = (XmRowColumnCallbackStruct *) xt_call_data ;
	trigOp = atoi(mb.mtext);
}


/*
** WorkShop Visual Stub longExe
*/

void longExe(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  ShowWatchCursor();
  longDisplay(0);
  ClearWatchCursor();
}


/*
** WorkShop Visual Stub longTrig
*/

void longTrig(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  ShowWatchCursor();
  longDisplay(1);
  ClearWatchCursor();
}

/* Long display */

void  longDisplay(int trigger)
{
int  j, sucs;
FILE *fp;
char displaystring[MAX_FILELEN], tempstring[100], tempstring1[100], temptext[12];
char temp1[100], temp2[200], temp3[4], temp4[200], temp5[16], temp6[16], temp7[5], tmpstr[40];
int  copies, totalch, isgps, longauto;
char yMinTemp[16][16], yMaxTemp[16][16];
int  trigchno, tr1=0, tr2=0;



	if (trigger == 1) {
	  trigchno = 0;
	  strcpy (tmpstr, (char *)XmTextFieldGetString(trigLevelText1) );
	  if (strlen(tmpstr) > 0 && tmpstr[0]!=' ')
	    tr1 = 1;
	  strcpy (tmpstr, (char *)XmTextFieldGetString(trigLevelText2) );
	  if (strlen(tmpstr) > 0 && tmpstr[0]!=' ')
	    tr2 = 1;
	  trigchno = tr1 + tr2;
	  if (trigchno == 0) {
	    printf ( "No trigger channel selected. Stop.\n" );
	    return;
	  }
	  else
	    printf ( "No. of trigger channel(s) = %d\n", trigchno );
	}
        if (mmMode) { /* frame */
	  if ( trend == 0 ) {
	    decimation = 0;
	    XmToggleButtonSetState(lfull, TRUE, TRUE);
	    printf ( "Full data file.\n" );
	  }
	  else if ( trend == 1 ) {
	    decimation = 1;
	    XmToggleButtonSetState(lsec, TRUE, TRUE);
	    printf ( "Second trend data file.\n" );
	  }
	  else if ( trend == 60 ) {
	    decimation = 60;
	    XmToggleButtonSetState(lmin1, TRUE, TRUE);
	    printf ( "Minute trend data file.\n" );
	  }
	}
	else { /* not allow UTC when Full Data chosen */
#if 0
	  if (decimation == 0) {
	    XmToggleButtonSetState(ltotal, TRUE, TRUE);
	  }
#endif
	}
	if ( XmToggleButtonGetState(autoset) ) 
	  longauto = 1;
	else {
	  longauto = 0;
	  for ( j=0; j<16; j++ ) {
	    strcpy(yMinTemp[j], yAxisMin[j]);
	    strcpy(yMaxTemp[j], yAxisMax[j]);
	  }
	}
	/* set timer */
	/*if (mmMode != 2 || trend == 0 ) {*/
	  if ( XmToggleButtonGetState(lutc) ) { /* UTC time */
	    isgps = 0;
	    strcpy( temptext, (char *)XmTextFieldGetString(playYr));
	    startyr = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(playMo));
	    startmo = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(playDa));
	    startda = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(playHr));
	    starthr = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(playMn));
	    startmn = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(playSc));
	    startsc = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(refTimeDay));
	    totalPlay.days = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(refTimeHr));
	    totalPlay.hours = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(refTimeMin));
	    totalPlay.mins = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(refTimeSec));
	    totalPlay.secs = atoi(temptext);
	    
	    if ( totalPlay.days == 0 && totalPlay.hours == 0
		 && totalPlay.mins == 0 && totalPlay.secs == 0 ) {
	    //  printMessage("Warning: no time duration selected for UTC Long Playback", 0);
		// Set ten minute default
		totalPlay.mins = 10;
		XmTextFieldSetString(refTimeMin, "10");
	    }
	    if (startyr==0 && startmo==0 && startda==0 && starthr==0 && startmn==0 && startsc==0 ) {
	      printMessage("Warning: no time selected for UTC Long Playback", 0);
	      return;
	    }
	  }
	  else { /* GPS time */
	    isgps = 1;
	    strcpy( temptext, (char *)XmTextFieldGetString(gpstime));
	    startgps = atoi(temptext);
	    strcpy( temptext, (char *)XmTextFieldGetString(gpsref));
	    durgps = atoi(temptext);
	    if ( startgps == 0 || durgps == 0) {
	      printMessage("Warning: no time/duration selected for GPS Long Playback", 0);
	      return;
	    }
	  }
	  /*}*/

	sprintf ( tempstring, "/tmp/%splayset", iniDir );
	//printf ( "writing file: %s\n", tempstring );
	fp = fopen(tempstring, "w");
	if ( fp == NULL ) {
	  sprintf ( tempstring1, "Can't open writing file: %s", tempstring );
	  printMessage(tempstring1, 0);
	  return;
	}
	/* auto setting & line style */
	fprintf ( fp, "%d\n", longauto );
	fprintf ( fp, "%d\n", linestyle );
	totalch = 0;

	{
	  //  Select first channel if nothing is selected
	  int i, t;
	  Widget w[16] = {lch1, lch2, lch3, lch4, lch5, lch6, lch7, lch8,
			  lch9, lch10, lch11, lch12, lch13, lch14, lch15, lch16};
	  for (i = 0, t = 0; i < 16; i++) t |= XmToggleButtonGetState(w[i]);
	  if (!t) XmToggleButtonSetState(lch1, TRUE, TRUE);
	}

	if ( XmToggleButtonGetState(lch1) ) {
	  fprintf ( fp, "%s\n", chName[0] );
	  if (eunit[0])
	    fprintf ( fp, "%s\n", chUnit[0] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 1 );
	  fprintf ( fp, "%d\n", xyType[0] );
	  if ( longauto == 0 ) { /* not auto, record y settings */
	    fprintf ( fp, "%s\n", yMinTemp[0] );
	    fprintf ( fp, "%s\n", yMaxTemp[0] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch2) ) {
	  fprintf ( fp, "%s\n", chName[1] );
	  if (eunit[1])
	    fprintf ( fp, "%s\n", chUnit[1] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 2 );
	  fprintf ( fp, "%d\n", xyType[1] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[1] );
	    fprintf ( fp, "%s\n", yMaxTemp[1] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch3) ) {
	  fprintf ( fp, "%s\n", chName[2] );
	  if (eunit[2])
	    fprintf ( fp, "%s\n", chUnit[2] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 3 );
	  fprintf ( fp, "%d\n", xyType[2] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[2] );
	    fprintf ( fp, "%s\n", yMaxTemp[2] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch4) ) {
	  fprintf ( fp, "%s\n", chName[3] );
	  if (eunit[3])
	    fprintf ( fp, "%s\n", chUnit[3] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 4 );
	  fprintf ( fp, "%d\n", xyType[3] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[3] );
	    fprintf ( fp, "%s\n", yMaxTemp[3] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch5) ) {
	  fprintf ( fp, "%s\n", chName[4] );
	  if (eunit[4])
	    fprintf ( fp, "%s\n", chUnit[4] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 5 );
	  fprintf ( fp, "%d\n", xyType[4] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[4] );
	    fprintf ( fp, "%s\n", yMaxTemp[4] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch6) ) {
	  fprintf ( fp, "%s\n", chName[5] );
	  if (eunit[5])
	    fprintf ( fp, "%s\n", chUnit[5] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 6 );
	  fprintf ( fp, "%d\n", xyType[5] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[5] );
	    fprintf ( fp, "%s\n", yMaxTemp[5] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch7) ) {
	  fprintf ( fp, "%s\n", chName[6] );
	  if (eunit[6])
	    fprintf ( fp, "%s\n", chUnit[6] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 7 );
	  fprintf ( fp, "%d\n", xyType[6] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[6] );
	    fprintf ( fp, "%s\n", yMaxTemp[6] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch8) ) {
	  fprintf ( fp, "%s\n", chName[7] );
	  if (eunit[7])
	    fprintf ( fp, "%s\n", chUnit[7] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 8 );
	  fprintf ( fp, "%d\n", xyType[7] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[7] );
	    fprintf ( fp, "%s\n", yMaxTemp[7] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch9) ) {
	  fprintf ( fp, "%s\n", chName[8] );
	  if (eunit[8])
	    fprintf ( fp, "%s\n", chUnit[8] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 9 );
	  fprintf ( fp, "%d\n", xyType[8] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[8] );
	    fprintf ( fp, "%s\n", yMaxTemp[8] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch10) ) {
	  fprintf ( fp, "%s\n", chName[9] );
	  if (eunit[9])
	    fprintf ( fp, "%s\n", chUnit[9] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 10 );
	  fprintf ( fp, "%d\n", xyType[9] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[9] );
	    fprintf ( fp, "%s\n", yMaxTemp[9] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch11) ) {
	  fprintf ( fp, "%s\n", chName[10] );
	  if (eunit[10])
	    fprintf ( fp, "%s\n", chUnit[10] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 11 );
	  fprintf ( fp, "%d\n", xyType[10] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[10] );
	    fprintf ( fp, "%s\n", yMaxTemp[10] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch12) ) {
	  fprintf ( fp, "%s\n", chName[11] );
	  if (eunit[11])
	    fprintf ( fp, "%s\n", chUnit[11] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 12 );
	  fprintf ( fp, "%d\n", xyType[11] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[11] );
	    fprintf ( fp, "%s\n", yMaxTemp[11] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch13) ) {
	  fprintf ( fp, "%s\n", chName[12] );
	  if (eunit[12])
	    fprintf ( fp, "%s\n", chUnit[12] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 13 );
	  fprintf ( fp, "%d\n", xyType[12] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[12] );
	    fprintf ( fp, "%s\n", yMaxTemp[12] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch14) ) {
	  fprintf ( fp, "%s\n", chName[13] );
	  if (eunit[13])
	    fprintf ( fp, "%s\n", chUnit[13] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 14 );
	  fprintf ( fp, "%d\n", xyType[13] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[13] );
	    fprintf ( fp, "%s\n", yMaxTemp[13] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch15) ) {
	  fprintf ( fp, "%s\n", chName[14] );
	  if (eunit[14])
	    fprintf ( fp, "%s\n", chUnit[14] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 15 );
	  fprintf ( fp, "%d\n", xyType[14] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[14] );
	    fprintf ( fp, "%s\n", yMaxTemp[14] );
	  }
	  totalch++;
	}
	if ( XmToggleButtonGetState(lch16) ) {
	  fprintf ( fp, "%s\n", chName[15] );
	  if (eunit[15])
	    fprintf ( fp, "%s\n", chUnit[15] );
	  else
	    fprintf ( fp, "no_conv.\n" );
	  fprintf ( fp, "%d\n", 16 );
	  fprintf ( fp, "%d\n", xyType[15] );
	  if ( longauto == 0 ) { 
	    fprintf ( fp, "%s\n", yMinTemp[15] );
	    fprintf ( fp, "%s\n", yMaxTemp[15] );
	  }
	  totalch++;
	}
	for ( j=0; j<totalch; j++ ) fprintf ( fp, "%d\n", gColor[j] );
	fprintf ( fp, "%d\n", multiple );
	fprintf ( fp, "%d\n", xaxisformat );
	fprintf ( fp, "%d\n", decimation );
	fprintf ( fp, "%d\n", XmToggleButtonGetState(xgrid) );
	fprintf ( fp, "%d\n", XmToggleButtonGetState(ygrid) );
	fprintf ( fp, "%d\n", XmToggleButtonGetState(lrms) );
	fprintf ( fp, "%d\n", XmToggleButtonGetState(lmax) );
	fprintf ( fp, "%d\n", XmToggleButtonGetState(lmin) );
	/*if (mmMode != 2 || trend == 0) {*/
	  if (mmMode)
	    fprintf ( fp, "%d\n", 1 );
	  else
	    fprintf ( fp, "%d\n", isgps);
	  if ( isgps == 0 ) {
	    if (!mmMode) {
	      fprintf ( fp, "%d\n", startyr);
	      fprintf ( fp, "%d\n", startmo );
	      fprintf ( fp, "%d\n", startda );
	      fprintf ( fp, "%d\n", starthr );
	      fprintf ( fp, "%d\n", startmn );
	      fprintf ( fp, "%d\n", startsc );
	      fprintf ( fp, "%d\n", totalPlay.days );
	      fprintf ( fp, "%d\n", totalPlay.hours );
	      fprintf ( fp, "%d\n", totalPlay.mins );
	      fprintf ( fp, "%d\n", totalPlay.secs );
	    }
	    else{
	      startgps = DataUTCtoGPS1(startyr,startmo,startda,starthr,startmn,startsc);
	      durgps = totalPlay.secs + totalPlay.mins*60 + (totalPlay.hours + totalPlay.days*24)*3600;
	      fprintf ( fp, "%ld\n", startgps );
	      fprintf ( fp, "%ld\n", durgps );
	    }
	  }
	  else { /* GPS isgps=1 */
	    fprintf ( fp, "%ld\n", startgps );
	    fprintf ( fp, "%ld\n", durgps );
	  }
	  fprintf ( fp, "%d\n", startstop );
	  /*}*/
	if (trigger == 1) {
	  fprintf ( fp, "%d\n", trigchno ); /* no of trigger channels */
	  if ( tr1 ) {
	    fprintf ( fp, "%s\n", chName[chanTrig1-1] );
	    fprintf ( fp, "%d\n", chRate[chanTrig1-1] );
	    if (eunit[chanTrig1-1])
	      fprintf ( fp, "%s\n", chUnit[chanTrig1-1] );
	    else
	    fprintf ( fp, "no_conv.\n" );
	    fprintf ( fp, "%d\n", trigHow1 );
	    fprintf ( fp, "%.2f\n", trigLev1 );
	  }
	  if ( tr2 ) {
	    fprintf ( fp, "%s\n", chName[chanTrig2-1] );
	    fprintf ( fp, "%d\n", chRate[chanTrig2-1] );
	    if (eunit[chanTrig2-1])
	      fprintf ( fp, "%s\n", chUnit[chanTrig2-1] );
	    else
	    fprintf ( fp, "no_conv.\n" );
	    fprintf ( fp, "%d\n", trigHow2 );
	    fprintf ( fp, "%.2f\n", trigLev2 );
	  }
	  fprintf ( fp, "%d\n", trigOp );
	}
	fclose(fp);
	

	if ( totalch <= 0 ) {
	  printMessage("Warning: No Channel selected for Long Playback", 0);
	  return;
	}
	if (mmMode) { /* frame files */
	  if ( trend == -1 ) {
	    printMessage("Error: No frame files opened", 0);
	    return;
	  }
	  copies = 1;
	  strcpy ( temptext, (char *)XmTextFieldGetString(lIPtext) );
	  printf ( "Long Playback File: %s\n", temptext );
	  sprintf ( temp2, "%s", origDir);
	  sprintf ( temp3, "%d", totalch);
	  sprintf ( temp4, "/tmp/%slongfile0", iniDir);
	  sprintf ( temp5, "%ld", fgps0);
	  sprintf ( temp6, "%ld", fgps1);
	  sprintf ( temp7, "%d", trend);
	  if ( mmMode == 1 ) {
	    sprintf ( displaystring, "%stocLongFile", origDir );
	    sprintf ( temp1, "/tmp/%splayset", iniDir );
	  }
	  else if ( mmMode == 2 ) {
	    sprintf ( displaystring, "%sfrLongFile", origDir );
	    sprintf ( temp1, "/tmp/%s", iniDir );
	  }
	  /* call tocLongFile */
	  if ( fork() == 0 ) {
	    if ( mmMode == 1 ) {
	      execlp(displaystring, "tocLongFile", temptext, temp1, temp2, temp3, temp4, temp5, temp6, temp7, (char*)NULL);
	      perror("Error in starting toc/frLongFile");
	      exit(0);
	    }
	    else if ( mmMode == 2 ) {
	      execlp(displaystring, "frLongFile", temptext, temp1, temp2, temp3, temp4, temp5, temp6, temp7, (char*)NULL);
	      perror("Error in starting toc/frLongFile");
	      exit(0);
	    }
	  }
	  else {
	    wait(&sucs);
	  }
	  if (sucs != 0) {
	    if ( mmMode == 1 )
	      printf ( "tocLongFile returns: %d\n", sucs );
	    else if ( mmMode == 2 )
	      printf ( "frLongFile returns: %d\n", sucs );
	    printMessage("No data output. No display", 0);
	    return;
	  }

	  sprintf ( displaystring, "%stocLongRead %s %s %s /tmp/%slongfile%d %d %d %d", origDir, tempstring, origDir, displayIP, iniDir, 0, 0, totalch, trend );
	  sprintf ( tempstring1, "/tmp/%sstartLong%d", iniDir, 0 );
	  fp = fopen(tempstring1, "w");
	  if ( fp == NULL ) {
	    printMessage("Fatal error for Long Playback: can't open writing file.", 0);
	    return;
	  }
	  fprintf ( fp, "%s\n", displaystring );
	  //fprintf ( stderr, "START: %s\n", displaystring );
	  fclose(fp);
	  
	  fproc = fork();
	  //printf ( "Fproc = %d\n", fproc );
	  if ( fproc == 0 ) {
	    if ( fork() == 0 ) {
	      //fprintf ( stderr, "Child executing shell\n" );
	      args[0] = "bash";
	      sprintf ( tempstring1, "/tmp/%sstartLong%d", iniDir, 0 );
	      free(args[1]);
	      args[1] = (char *) malloc(500*sizeof(char));
	      strcpy(args[1], tempstring1);
	      args[2] = NULL;
	      execv( "/bin/bash", args );
	      perror("Fork error");
	      exit(0);
	    }
	    else
	      exit(0);
	  }
	  else
	    wait(0);
	}
	else {
	  if ( multiple == -1 ) 
	    copies = totalch;
	  else 
	    copies = 1;
	  strcpy ( serverLongIP, (char *)XmTextFieldGetString(serverIpText) );
	  strcpy ( temptext, (char *)XmTextFieldGetString(serverPortText) );
	  serverLongPort = atoi(temptext);
	  //printf ( "Long Playback Server: %s-%d\n", serverLongIP, serverLongPort );
	  for ( j=0; j<copies; j++ ) { 
	    if (!trigger)
	      sprintf ( displaystring, "%sframeMemRead%s %s %d %s %s %s /tmp/%slongfile%d %d %d", origDir, plotterNum == 3? "XMGR": "", serverLongIP, serverLongPort, tempstring, origDir, displayIP, iniDir, j, j, totalch );
	    else
	      sprintf ( displaystring, "%sframeMemTrig %s %d %s %s %s /tmp/%slongfile%d %d %d", origDir, serverLongIP, serverLongPort, tempstring, origDir, displayIP, iniDir, j, j, totalch );
	    sprintf ( tempstring1, "/tmp/%sstartLong%d", iniDir, j );
	    fp = fopen(tempstring1, "w");
	    if ( fp == NULL ) {
	      printMessage("Fatal error for Long Playback: can't open writing file.", 0);
	      return;;
	    }
	    fprintf ( fp, "exec %s\n", displaystring );
	    //fprintf ( stderr, "START: %s\n", displaystring );
	    fclose(fp);
	    
	    fproc = fork();
	    //printf ( "Fproc = %d\n", fproc );
	    if ( fproc == 0 ) {
	      //fprintf ( stderr, "Child executing shell\n" );
	      args[0] = "bash";
	      sprintf ( tempstring1, "/tmp/%sstartLong%d", iniDir, j );
	      free(args[1]);
	      args[1] = (char *) malloc(500*sizeof(char));
	      strcpy(args[1], tempstring1);
	      args[2] = NULL;
	      execv( "/bin/bash", args );
	      perror("Fork error");
	      exit(0);
	    }
	    else  {
		//wait(0);
	    }
	  }
	}
}
/*
** WorkShop Visual Stub SaveListXml
*/

void SaveListXml(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	xml_only = 1;
	nseldir = -1;
	Ashowlist();
}

/*
** WorkShop Visual Stub SaveListAll
*/

void SaveListAll(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data ;
	xml_only = 0;
	nseldir = -1;
	Ashowlist();
}


#if 1

/*
** Drop Functions - manually added
*/

void drop_v1(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 1;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v2(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 2;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v3(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 3;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v4(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 4;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v5(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 5;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v6(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 6;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v7(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 7;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v8(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 8;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v9(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 9;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v10(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 10;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v11(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 11;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v12(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 12;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v13(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 13;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v14(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 14;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v15(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 15;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

void drop_v16(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
XmDropProcCallback     DropData;
XmDropTransferEntryRec  transferEntries[2];
XmDropTransferEntry     transferList;
Arg                    al[10];
int                    ac;
Widget                 dc;

        drop_ch = 16;
	DropData = (XmDropProcCallback) xt_call_data;
	dc = DropData->dragContext;
        ac = 0;
	if (DropData->dropAction == XmDROP) {
	  XtSetArg (al[ac], XmNtransferStatus, XmTRANSFER_SUCCESS); ac++;
	  /*XtSetArg (al[ac], XmNnumDropTransfers, 0); ac++;*/
	  transferEntries[0].target = COMPOUND_TEXT;
	  transferEntries[0].client_data = (XtPointer)w;
	  transferList = transferEntries;
	  XtSetArg(al[ac], XmNdropTransfers, transferList); ac++;
	  XtSetArg(al[ac], XmNnumDropTransfers, 1); ac++;
	  XtSetArg(al[ac], XmNtransferProc, TransferProc); ac++;	
	}
        XmDropTransferStart (dc, al, ac);

	return;
}

/* Handle dropped signal */
void TransferProc (Widget w, XtPointer client_data, Atom *seltype,
		   Atom *type, XtPointer value,
		   unsigned long *length, int format )
{
  char tempch[MAX_LONG_CHANNEL_NAME_LENGTH + 1];
  char tempstring[MAX_LONG_CHANNEL_NAME_LENGTH + 80];
  int  v_rate;
  Boolean   status;
  char *ascii_string;
  XmString xstring;

  /* information from the drag initiator is passed in
     compound text format. drop site is client_data */
  Widget v_text = (Widget)client_data;   

  COMPOUND_TEXT = XmInternAtom (XtDisplay (v_text), "COMPOUND_TEXT", False);

  if (*type == COMPOUND_TEXT) {
    xstring = XmCvtCTToXmString( (char *) value );
    status = XmStringGetLtoR( xstring, XmFONTLIST_DEFAULT_TAG, &ascii_string );
    XmStringFree( xstring );
    if (status) {
      /*sprintf ( tempch, "%s", ascii_string );*/
      sscanf ( ascii_string, "%s %s", tempch, tempstring );
      //	     printf ( "Drop value received: %s\n", tempch);
      XtFree( ascii_string );
      v_rate = signalVerify (drop_ch, tempch);
      if ( v_rate > 0 ) {
	XmTextFieldSetString(v_text, "" );
	sprintf ( tempstring, "%d: %s", drop_ch, tempch);
	XmTextFieldSetString(v_text, tempstring );
	//	       printf ( "Drop succeed.\n");
      }
      else 
	printf ( "Drop failed. Ch%d unchanged.\n", drop_ch);
    }
    else 
      printf ( "Warning: can't convert the drop string. Drop failed.\n");
  }
  else 
    printf ( "Warning: Drop value not accepted.\n");
  XtFree( (char *) value );
  return;
}

#endif

/* Verify selected signal and load it to desired channel. Return 
   signal rate or -1 if not a valid channel */
/* called by TransferProc & signalSelect */

int signalVerify (int chanNo, char chanV[]) {
  int  c, j, ch_found = -1;

  /* test if chanV is a valid signal name */
  //printf ( "Verifying %s ...\n", chanV);
  c = DataChanList(allChan);
  //	printf ( "Comparing with %d channels\n", c);
  for ( j=0; j<c; j++ ) {
    if (strncmp(allChan[j].name, chanV, strlen(allChan[j].name))==0) {
      ch_found = j;
      break;
    } 
  }
  if ( ch_found < 0 ) {
    printf ("\"%s\" is not a valid signal name!\n", chanV);
    XBell(display, 1);
    return -1;
  }

  /* new signal selected */
  sprintf ( chChange, "%d", chanNo );
  strcpy(mb.mtext, chChange );
  mb.mtype = 10; 
  msgsnd ( msqid, &mb, MSQSIZE, 0 );
  XmTextFieldSetString(selchan, chChange);

  strcpy ( chName[chanNo-1], chanV );
  if (strcmp(allChan[ch_found].units, " ")==0) 
    strcpy(allChan[ch_found].units, "None");	
  strcpy ( chUnit[chanNo-1], allChan[ch_found].units);
  chRate[chanNo-1] = allChan[ch_found].rate;
  strcpy(mb.mtext, chanV);
  mb.mtype = 3;
  msgsnd(msqid, &mb, MSQSIZE, 0);
  //printf ( "ch.%d new signal: %s, sample rate %d\n", chanNo, mb.mtext, chRate[chanNo-1] );
  mb.mtype = 13;
  strcpy ( mb.mtext, chUnit[chanNo-1] );
  msgsnd(msqid, &mb, MSQSIZE, 0);

  //XmTextFieldSetString(selsig, "" );
  XmTextFieldSetString(selsig, chanV );
  if (chanNo == chSelected+1) {
    SetStringWidget(sigNamText, chanV);
  }
  SelChIncr(0,0,0);
  return chRate[chanNo-1];
}


/*
** WorkShop Visual Stub restoreSettings
*/

void saveOKSel(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  FILE *fp;
  char tmpstr[400], templine[200], term1[200], term2[200], nametag[80];
  int  tmpint, chtag, j;
  char tempst[16];  /* check version number */
  
  strcpy ( saveFileName, (char *)XmTextFieldGetString(savefile) );
  fp = fopen(saveFileName, "w");
  if ( fp == NULL ) {
    sprintf ( tmpstr, "Can't open writing file: %s", saveFileName );
    printMessage(tmpstr, 0);
    return;
  }
  else {
    sprintf ( tmpstr, "writing file: %s", saveFileName );
    printMessage(tmpstr, 0);
  }
  fprintf ( fp, "<?xml version=\"1.0\" encoding=\"ISO-8859-1\" standalone=\"yes\"?>\n\n" );
  fprintf ( fp, "<DATAVIEWER>\n" );
  fprintf ( fp, "<VERSION>%s</VERSION>\n", version_n );
  fprintf ( fp, "<CHANNO>%d</CHANNO>\n", windowNum  );
  fprintf ( fp, "<!-- channel features -->\n" );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<NAME ch=\"%d\">%s</NAME>\n", i+1, chName[i] );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<RATE ch=\"%d\">%d</RATE>\n", i+1, chRate[i] );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<UNIT ch=\"%d\">%s</UNIT>\n", i+1, chUnit[i] );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<YMIN ch=\"%d\">%s</YMIN>\n", i+1, yAxisMin[i]);
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<YMAX ch=\"%d\">%s</YMAX>\n", i+1, yAxisMax[i]);
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<XSCALE ch=\"%d\">%s</XSCALE>\n", i+1, xAxisScale[i]);
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<XDELAY ch=\"%d\">%s</XDELAY>\n", i+1, xAxisDelay[i]);
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<XYTYPE ch=\"%d\">%d</XYTYPE>\n", i+1, xyType[i] );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<EUNIT ch=\"%d\">%d</EUNIT>\n", i+1,  eunit[i] );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<AUTO ch=\"%d\">%d</AUTO>\n", i+1,  autoon[i] );
  for ( i=0; i<16; i++ ) 
    fprintf ( fp, "<COLOR ch=\"%d\">%d</COLOR>\n", i+1,  gColor[i] );
  fprintf ( fp, "<!-- global feature -->\n" );
  fprintf ( fp, "<GRAPHOPTION>%d</GRAPHOPTION>\n", graphOption );
  fprintf ( fp, "<GRAPHMODE>%d</GRAPHMODE>\n", graphMode );
  fprintf ( fp, "<CHSELECTED>%d</CHSELECTED>\n", chSelected );
  fprintf ( fp, "<GLOBAL>%d</GLOBAL>\n", XmToggleButtonGetState(globalOn) );
  fprintf ( fp, "<TRIGGER ch=\"%d\">%d</TRIGGER>\n", chanTrig, XmToggleButtonGetState(trigOn) );
  fprintf ( fp, "<TRIGGERLEV>%.2f</TRIGGERLEV>\n", trigLev );
  fprintf ( fp, "<SIGON>%d</SIGON>\n", XmToggleButtonGetState(sigOn) );
  fprintf ( fp, "<RESOLUTION>%d</RESOLUTION>\n", resolution );
  fprintf ( fp, "<REFRESHRATE>%d</REFRESHRATE>\n", refreshrate );
  fprintf ( fp, "<FILTER>%d</FILTER>\n", XmToggleButtonGetState(filterOn) );
  fprintf ( fp, "<CHMARKED>%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d</CHMARKED>\n", chMarked[0], chMarked[1], chMarked[2], chMarked[3], chMarked[4], chMarked[5], chMarked[6], chMarked[7], chMarked[8], chMarked[9], chMarked[10], chMarked[11], chMarked[12], chMarked[13], chMarked[14], chMarked[15] );
  fprintf ( fp, "\n</DATAVIEWER>\n" );
  fclose(fp);
}

/*
** WorkShop Visual Stub connectToServer
*/

void connectToServer(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  char buf[1024];
  //sprintf(buf, "Connecting to \"%s\"...", serverIP);
  //SetStringWidget(statusField, buf);
  ShowWatchCursor();
  stopButton(0,0,0); // Stop running
  sleep(1);
  if (serverConnect() == 0) {
    updateStatusField();

	  // Redraw signal selection dialog
	  //XtUnrealizeWidget (signal_Sel);
	  //create_signal_Sel(shell1);
//	  doStuff();
	  fastSel(0,0,0);

	  // Restart framer4 and grace processes
	  if (!firstTime) {
	    mb.mtype = 23;
	    strcpy ( mb.mtext, "0" );
	    msgsnd ( msqid, &mb, MSQSIZE, 0 );
	    sleep(1);
	    startXmgr(0);
	    SetStringWidget(actionText,"Stop");
	  }
  } else {
	sprintf(buf, "Couldn't connect to %s", serverIP);
	errorMessage(buf);
  }
  ClearWatchCursor();
}


/* Event Handler Stub Functions */

/*
** WorkShop Visual Stub sigSet
*/

void sigSet(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	int chnum = (long) client_data;
	if (chnum <= 16 ) {
          sprintf (chChange, "%d", chnum);
	  XmTextFieldSetString(selchan, chChange);
	}
}

/*
** WorkShop Visual Stub sigNumModifyVerify
*/

void sigNumModifyVerify(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	XmTextVerifyCallbackStruct *call_data = (XmTextVerifyCallbackStruct *) xt_call_data ;
        Widget vees [16] = {v1,v2,v3,v4,v5,v6,v7,v8,v9,v10,v11,v12,v13,v14,v15,v16};
	int j = atoi ((char *)XmTextFieldGetString(w));
	if ( j > 0 && j < 17 ) {
	  int k;
	  extern Display *display;
       	  Arg al[64];                    /* Arg List */
	  Pixel pixel;

	  XtSetArg(al[0], XmNbackground, &pixel); 
	  XtGetValues(XtParent(w), al, 1);
	  XtSetArg(al[0], XmNborderColor, pixel); 
	  for (k = 0; k < 16; k++) XtSetValues(vees[k], al, 1); 
	  XtSetArg(al[0], XmNhighlightColor, &pixel); 
	  XtGetValues(w, al, 1);
	  XtSetArg(al[0], XmNborderColor, pixel);
 	  XtSetValues(vees[j-1], al, 1); 
	}
}

/*
** WorkShop Visual Stub verifyInt
*/

void verifyInt(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	char *endptr;
	XmTextVerifyCallbackStruct *call_data = (XmTextVerifyCallbackStruct *) xt_call_data;
	if (!call_data->text->ptr) return;
	strtol(call_data->text->ptr, &endptr, 10);
	if (endptr != (call_data->text->ptr + strlen(call_data->text->ptr)))
	  call_data->doit = False;
}


/*
** WorkShop Visual Stub verifyNoSpaces
*/

void verifyNoSpaces(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
        char *ptr = ((XmTextVerifyCallbackStruct *) xt_call_data) -> text -> ptr;
        if (!ptr) return;
	for (; *ptr; ptr++)
	  if (isspace(*ptr)) {
		((XmTextVerifyCallbackStruct *) xt_call_data) -> doit = False;
		return;
	  }
}


/*
** WorkShop Visual Stub newNdsPortNumber
*/

void newNdsPortNumber(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	char *str = XmTextFieldGetString(w);
	serverPort = atoi(str);
	XtFree(str);
}

/*
** WorkShop Visual Stub newNdsServer
*/

void newNdsServer(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	char *str = XmTextFieldGetString(serverIpText);
	strcpy(serverIP, str);
	XtFree(str);
}

/*
** WorkShop Visual Stub newPlotDisplay
*/

void newPlotDisplay(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	char *str = XmTextFieldGetString(w);
	strcpy(displayIP, str);
	XtFree(str);
}

/*
** WorkShop Visual Stub restartXmgr
*/

void restartXmgr(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  stopButton(0,0,0); // Stop running
  sleep(1);
  ShowWatchCursor();
  sprintf(mb.mtext, "%d", MMNEW);
  SelectMainMenu(0,0,0);
  //showPage(0, (XtPointer)2, 0);
  ClearWatchCursor();
}


unregisterDropSites() {
	Widget w[] = { serverIpText, serverPortText, plotDisplay,
			trigLevelText, yMinText, yMaxText, lidtext,
			trigLevelText2, trigLevelText1, 		
			lIPtext, lPorttext,
			playYr, playMo, playDa, playHr, playMn, playSc,
			gpstime, refTimeDay, refTimeHr, refTimeMin, refTimeSec,
			gpsref};
	for (i = 0; i < sizeof(w)/sizeof(w[0]); i++)
		XmDropSiteUnregister(w[i]);
}
/*
** WorkShop Visual Stub setPlotter
*/

void setPlotter(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
  plotterNum = XmToggleButtonGetState(xmgraceToggle)? 4: 3;
}

/*
** WorkShop Visual Stub stopPlayback
*/

void stopPlayback(Widget w, XtPointer client_data, XtPointer xt_call_data)
{
	if (fproc) {
		//printf("sending kill signal to %d\n", fproc);
		kill(fproc, SIGKILL);
		sleep(1);
		printf("\nTerminated process %d\n", fproc);
		fproc = 0;
	}
}

