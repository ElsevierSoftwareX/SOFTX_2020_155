/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "gdsrsched.h"
#ifndef _KERNEL
#endif /* !_KERNEL */
#define		_RPC_CLNT
#include "dtt/rpcinc.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

enum clnt_stat 
closescheduler_1(scheduler_r *sd, tainsec_r timeout, int *clnt_res, CLIENT *clnt)
{
	closescheduler_1_argument arg;
	arg.sd = sd;
	arg.timeout = timeout;
	return (clnt_call(clnt, CLOSESCHEDULER,
		(xdrproc_t) xdr_closescheduler_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
scheduletask_1(scheduler_r *sd, schedulertask_r *newtask, int *clnt_res, CLIENT *clnt)
{
	scheduletask_1_argument arg;
	arg.sd = sd;
	arg.newtask = newtask;
	return (clnt_call(clnt, SCHEDULETASK,
		(xdrproc_t) xdr_scheduletask_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
getscheduledtask_1(scheduler_r *sd, int id, resultGetScheduledTask_r *clnt_res, CLIENT *clnt)
{
	getscheduledtask_1_argument arg;
	arg.sd = sd;
	arg.id = id;
	return (clnt_call(clnt, GETSCHEDULEDTASK,
		(xdrproc_t) xdr_getscheduledtask_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_resultGetScheduledTask_r, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
removescheduledtask_1(scheduler_r *sd, int id, int terminate, int *clnt_res, CLIENT *clnt)
{
	removescheduledtask_1_argument arg;
	arg.sd = sd;
	arg.id = id;
	arg.terminate = terminate;
	return (clnt_call(clnt, REMOVESCHEDULEDTASK,
		(xdrproc_t) xdr_removescheduledtask_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
waitforschedulertofinish_1(scheduler_r *sd, tainsec_r timeout, int *clnt_res, CLIENT *clnt)
{
	waitforschedulertofinish_1_argument arg;
	arg.sd = sd;
	arg.timeout = timeout;
	return (clnt_call(clnt, WAITFORSCHEDULERTOFINISH,
		(xdrproc_t) xdr_waitforschedulertofinish_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
settagnotify_1(scheduler_r *sd, char *tag, tainsec_r time, int *clnt_res, CLIENT *clnt)
{
	settagnotify_1_argument arg;
	arg.sd = sd;
	arg.tag = tag;
	arg.time = time;
	return (clnt_call(clnt, SETTAGNOTIFY,
		(xdrproc_t) xdr_settagnotify_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
connectscheduler_1(scheduler_r *callbacksd, u_int callbackprogram, u_int callbackversion, remotesched_r *clnt_res, CLIENT *clnt)
{
	connectscheduler_1_argument arg;
	arg.callbacksd = callbacksd;
	arg.callbackprogram = callbackprogram;
	arg.callbackversion = callbackversion;
	return (clnt_call(clnt, CONNECTSCHEDULER,
		(xdrproc_t) xdr_connectscheduler_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_remotesched_r, (caddr_t) clnt_res,
		TIMEOUT));
}

enum clnt_stat 
settagcallback_1(scheduler_r *sd, scheduler_r *bsd, char *tag, tainsec_r time, int *clnt_res, CLIENT *clnt)
{
	settagcallback_1_argument arg;
	arg.sd = sd;
	arg.bsd = bsd;
	arg.tag = tag;
	arg.time = time;
	return (clnt_call(clnt, SETTAGCALLBACK,
		(xdrproc_t) xdr_settagcallback_1_argument, (caddr_t) &arg,
		(xdrproc_t) xdr_int, (caddr_t) clnt_res,
		TIMEOUT));
}
