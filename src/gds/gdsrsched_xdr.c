/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "gdsrsched.h"
#define		_RPC_XDR
#include "dtt/rpcinc.h"

bool_t
xdr_tainsec_r(register XDR *xdrs, tainsec_r *objp)
{

#if defined(_LP64) || defined(_KERNEL)
	register int *buf;
#else
	register long *buf;
#endif

	if (!xdr_longlong_t(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_scheduler_r(register XDR *xdrs, scheduler_r *objp)
{

#if defined(_LP64) || defined(_KERNEL)
	register int *buf;
#else
	register long *buf;
#endif

	int i;
	if (!xdr_opaque(xdrs, objp->scheduler_r, ADDRLEN))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_schedulertask_r(register XDR *xdrs, schedulertask_r *objp)
{

#if defined(_LP64) || defined(_KERNEL)
	register int *buf;
#else
	register long *buf;
#endif

	int i;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = XDR_INLINE(xdrs, 14 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->flag))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->priority))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->tagtype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->synctype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->syncval))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->waittype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeattype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatval))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatratetype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatrate))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatsynctype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatsyncval))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->func))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->arg_sizeof))
				return (FALSE);

		} else {
#if defined(_LP64) || defined(_KERNEL)
			IXDR_PUT_INT32(buf, objp->flag);
			IXDR_PUT_INT32(buf, objp->priority);
			IXDR_PUT_INT32(buf, objp->tagtype);
			IXDR_PUT_INT32(buf, objp->synctype);
			IXDR_PUT_INT32(buf, objp->syncval);
			IXDR_PUT_INT32(buf, objp->waittype);
			IXDR_PUT_INT32(buf, objp->repeattype);
			IXDR_PUT_INT32(buf, objp->repeatval);
			IXDR_PUT_INT32(buf, objp->repeatratetype);
			IXDR_PUT_INT32(buf, objp->repeatrate);
			IXDR_PUT_INT32(buf, objp->repeatsynctype);
			IXDR_PUT_INT32(buf, objp->repeatsyncval);
			IXDR_PUT_INT32(buf, objp->func);
			IXDR_PUT_INT32(buf, objp->arg_sizeof);
#else
			IXDR_PUT_LONG(buf, objp->flag);
			IXDR_PUT_LONG(buf, objp->priority);
			IXDR_PUT_LONG(buf, objp->tagtype);
			IXDR_PUT_LONG(buf, objp->synctype);
			IXDR_PUT_LONG(buf, objp->syncval);
			IXDR_PUT_LONG(buf, objp->waittype);
			IXDR_PUT_LONG(buf, objp->repeattype);
			IXDR_PUT_LONG(buf, objp->repeatval);
			IXDR_PUT_LONG(buf, objp->repeatratetype);
			IXDR_PUT_LONG(buf, objp->repeatrate);
			IXDR_PUT_LONG(buf, objp->repeatsynctype);
			IXDR_PUT_LONG(buf, objp->repeatsyncval);
			IXDR_PUT_LONG(buf, objp->func);
			IXDR_PUT_LONG(buf, objp->arg_sizeof);
#endif
		}
		if (!xdr_tainsec_r(xdrs, &objp->timeout))
			return (FALSE);
		if (!xdr_tainsec_r(xdrs, &objp->waitval))
			return (FALSE);
		if (!xdr_vector(xdrs, (char *)objp->timetag, RTIMETAG_LENGTH,
			sizeof (char), (xdrproc_t) xdr_char))
			return (FALSE);
		if (!xdr_vector(xdrs, (char *)objp->waittag, RTIMETAG_LENGTH,
			sizeof (char), (xdrproc_t) xdr_char))
			return (FALSE);
		if (!xdr_bytes(xdrs, (char **)&objp->arg.arg_val, (u_int *) &objp->arg.arg_len, ~0))
			return (FALSE);
		return (TRUE);
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = XDR_INLINE(xdrs, 14 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_int(xdrs, &objp->flag))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->priority))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->tagtype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->synctype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->syncval))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->waittype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeattype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatval))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatratetype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatrate))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatsynctype))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->repeatsyncval))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->func))
				return (FALSE);
			if (!xdr_int(xdrs, &objp->arg_sizeof))
				return (FALSE);

		} else {
#if defined(_LP64) || defined(_KERNEL)
			objp->flag = IXDR_GET_INT32(buf);
			objp->priority = IXDR_GET_INT32(buf);
			objp->tagtype = IXDR_GET_INT32(buf);
			objp->synctype = IXDR_GET_INT32(buf);
			objp->syncval = IXDR_GET_INT32(buf);
			objp->waittype = IXDR_GET_INT32(buf);
			objp->repeattype = IXDR_GET_INT32(buf);
			objp->repeatval = IXDR_GET_INT32(buf);
			objp->repeatratetype = IXDR_GET_INT32(buf);
			objp->repeatrate = IXDR_GET_INT32(buf);
			objp->repeatsynctype = IXDR_GET_INT32(buf);
			objp->repeatsyncval = IXDR_GET_INT32(buf);
			objp->func = IXDR_GET_INT32(buf);
			objp->arg_sizeof = IXDR_GET_INT32(buf);
#else
			objp->flag = IXDR_GET_LONG(buf);
			objp->priority = IXDR_GET_LONG(buf);
			objp->tagtype = IXDR_GET_LONG(buf);
			objp->synctype = IXDR_GET_LONG(buf);
			objp->syncval = IXDR_GET_LONG(buf);
			objp->waittype = IXDR_GET_LONG(buf);
			objp->repeattype = IXDR_GET_LONG(buf);
			objp->repeatval = IXDR_GET_LONG(buf);
			objp->repeatratetype = IXDR_GET_LONG(buf);
			objp->repeatrate = IXDR_GET_LONG(buf);
			objp->repeatsynctype = IXDR_GET_LONG(buf);
			objp->repeatsyncval = IXDR_GET_LONG(buf);
			objp->func = IXDR_GET_LONG(buf);
			objp->arg_sizeof = IXDR_GET_LONG(buf);
#endif
		}
		if (!xdr_tainsec_r(xdrs, &objp->timeout))
			return (FALSE);
		if (!xdr_tainsec_r(xdrs, &objp->waitval))
			return (FALSE);
		if (!xdr_vector(xdrs, (char *)objp->timetag, RTIMETAG_LENGTH,
			sizeof (char), (xdrproc_t) xdr_char))
			return (FALSE);
		if (!xdr_vector(xdrs, (char *)objp->waittag, RTIMETAG_LENGTH,
			sizeof (char), (xdrproc_t) xdr_char))
			return (FALSE);
		if (!xdr_bytes(xdrs, (char **)&objp->arg.arg_val, (u_int *) &objp->arg.arg_len, ~0))
			return (FALSE);
		return (TRUE);
	}

	if (!xdr_int(xdrs, &objp->flag))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->priority))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->tagtype))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->synctype))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->syncval))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->waittype))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->repeattype))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->repeatval))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->repeatratetype))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->repeatrate))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->repeatsynctype))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->repeatsyncval))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->func))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->arg_sizeof))
		return (FALSE);
	if (!xdr_tainsec_r(xdrs, &objp->timeout))
		return (FALSE);
	if (!xdr_tainsec_r(xdrs, &objp->waitval))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->timetag, RTIMETAG_LENGTH,
		sizeof (char), (xdrproc_t) xdr_char))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->waittag, RTIMETAG_LENGTH,
		sizeof (char), (xdrproc_t) xdr_char))
		return (FALSE);
	if (!xdr_bytes(xdrs, (char **)&objp->arg.arg_val, (u_int *) &objp->arg.arg_len, ~0))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_resultGetScheduledTask_r(register XDR *xdrs, resultGetScheduledTask_r *objp)
{

#if defined(_LP64) || defined(_KERNEL)
	register int *buf;
#else
	register long *buf;
#endif

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	if (!xdr_schedulertask_r(xdrs, &objp->task))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_remotesched_r(register XDR *xdrs, remotesched_r *objp)
{

#if defined(_LP64) || defined(_KERNEL)
	register int *buf;
#else
	register long *buf;
#endif

	if (!xdr_int(xdrs, &objp->status))
		return (FALSE);
	if (!xdr_scheduler_r(xdrs, &objp->sd))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_closescheduler_1_argument(register XDR *xdrs, closescheduler_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_tainsec_r(xdrs, &objp->timeout))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_scheduletask_1_argument(register XDR *xdrs, scheduletask_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->newtask, sizeof (schedulertask_r), (xdrproc_t) xdr_schedulertask_r))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_getscheduledtask_1_argument(register XDR *xdrs, getscheduledtask_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->id))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_removescheduledtask_1_argument(register XDR *xdrs, removescheduledtask_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->id))
		return (FALSE);
	if (!xdr_int(xdrs, &objp->terminate))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_waitforschedulertofinish_1_argument(register XDR *xdrs, waitforschedulertofinish_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_tainsec_r(xdrs, &objp->timeout))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_settagnotify_1_argument(register XDR *xdrs, settagnotify_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->tag, RTIMETAG_LENGTH))
		return (FALSE);
	if (!xdr_tainsec_r(xdrs, &objp->time))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_connectscheduler_1_argument(register XDR *xdrs, connectscheduler_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->callbacksd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->callbackprogram))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->callbackversion))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_settagcallback_1_argument(register XDR *xdrs, settagcallback_1_argument *objp)
{

	if (!xdr_pointer(xdrs, (char **)&objp->sd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_pointer(xdrs, (char **)&objp->bsd, sizeof (scheduler_r), (xdrproc_t) xdr_scheduler_r))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->tag, RTIMETAG_LENGTH))
		return (FALSE);
	if (!xdr_tainsec_r(xdrs, &objp->time))
		return (FALSE);
	return (TRUE);
}
