diff -r -u -d linux-source-4.19.orig/arch/x86/kernel/smpboot.c linux-source-4.19.cs/arch/x86/kernel/smpboot.c
--- linux-source-4.19.orig/arch/x86/kernel/smpboot.c	2019-04-27 02:36:41.000000000 -0500
+++ linux-source-4.19.cs/arch/x86/kernel/smpboot.c	2019-09-04 10:44:14.997185804 -0500
@@ -1559,6 +1559,18 @@
 	common_cpu_die(cpu);
 }
 
+static DEFINE_PER_CPU(void (*)(void), fe_code);
+
+int is_cpu_taken_by_rcg_model(unsigned int cpu) {
+        return 0 != per_cpu(fe_code, cpu);
+}
+EXPORT_SYMBOL(is_cpu_taken_by_rcg_model);
+
+void set_fe_code_idle(void (*ptr)(void), unsigned int cpu) {
+       per_cpu(fe_code, cpu) = ptr;
+}
+EXPORT_SYMBOL(set_fe_code_idle);
+
 void play_dead_common(void)
 {
 	idle_task_exit();
@@ -1570,6 +1582,10 @@
 	 * With physical CPU hotplug, we should halt the cpu
 	 */
 	local_irq_disable();
+        if (per_cpu(fe_code, smp_processor_id())) {
+	       // Execute front-end code
+	       (*per_cpu(fe_code, smp_processor_id()))();
+	}
 }
 
 static bool wakeup_cpu0(void)
diff -r -u -d linux-source-4.19.orig/kernel/cpu.c linux-source-4.19.cs/kernel/cpu.c
--- linux-source-4.19.orig/kernel/cpu.c	2019-08-07 21:02:38.000000000 -0500
+++ linux-source-4.19.cs/kernel/cpu.c	2019-09-04 10:44:14.997185804 -0500
@@ -1160,7 +1160,7 @@
 {
 	return do_cpu_up(cpu, CPUHP_ONLINE);
 }
-EXPORT_SYMBOL_GPL(cpu_up);
+EXPORT_SYMBOL(cpu_up);
 
 #ifdef CONFIG_PM_SLEEP_SMP
 static cpumask_var_t frozen_cpus;
