--- a/src/daqd/daqd.cc	(revision 4237)
+++ b/src/daqd/daqd.cc	(working copy)
@@ -1689,142 +1689,18 @@
 }
 
 void regerr() { abort();};
-#define ESIZE 1024
-char ipexpbuf [ESIZE];
-char dec_num_expbuf [ESIZE];
 
-char *cur_regexp = 0;
+regex_t ip_regex;
+//regex_t dec_num_regex;
+
 char *ipregexp ="^([0-9]\\{1,3\\}\\.)\\{3\\}[0-9]\\{1,3\\}$";
-char *dec_num_regexp = "^[0-9]\\{1,\\}$";
+//char *dec_num_regexp = "^[0-9]\\{1,\\}$";
 
-#define INIT         register char *sp = cur_regexp;
-#define GETC()       (*sp++)
-#define PEEKC()      (*sp)
-#define UNGETC(c)    (--sp)
-#define RETURN(c)    ;
-#define __DO_NOT_DEFINE_COMPILE
-#define ERROR(c)     ;
-#include <regexp.h>
-
-// This was snatched from /usr/include/regexp.h on a redhat 8 system
-// The reason for this was a signed/unsigned char C++ compile bug.
-
-/* Get and compile the user supplied pattern up to end of line or
-   string or until EOF is seen, whatever happens first.  The result is
-   placed in the buffer starting at EXPBUF and delimited by ENDBUF.
-
-   This function cannot be defined in the libc itself since it depends
-   on the macros.  */
-char *
-compile (char *__restrict instring, char *__restrict expbuf,
-	 __const char *__restrict endbuf, int eof)
-{
-  char *__input_buffer = NULL;
-  size_t __input_size = 0;
-  size_t __current_size = 0;
-  int __ch;
-  int __error;
-  INIT
-
-  /* Align the expression buffer according to the needs for an object
-     of type `regex_t'.  Then check for minimum size of the buffer for
-     the compiled regular expression.  */
-  regex_t *__expr_ptr;
-# if defined __GNUC__ && __GNUC__ >= 2
-  const size_t __req = __alignof__ (regex_t *);
-# else
-  /* How shall we find out?  We simply guess it and can change it is
-     this really proofs to be wrong.  */
-  const size_t __req = 8;
-# endif
-  expbuf += __req;
-  expbuf -= (expbuf - ((char *) 0)) % __req;
-  if (endbuf < expbuf + sizeof (regex_t))
-    {
-      ERROR (50);
-    }
-  __expr_ptr = (regex_t *) expbuf;
-  /* The remaining space in the buffer can be used for the compiled
-     pattern.  */
-  __expr_ptr->buffer = (unsigned char *)expbuf + sizeof (regex_t);
-  __expr_ptr->allocated = endbuf -  (char *) __expr_ptr->buffer;
-
-  while ((__ch = (GETC ())) != eof)
-    {
-      if (__ch == '\0' || __ch == '\n')
-	{
-	  UNGETC (__ch);
-	  break;
-	}
-
-      if (__current_size + 1 >= __input_size)
-	{
-	  size_t __new_size = __input_size ? 2 * __input_size : 128;
-	  char *__new_room = (char *) alloca (__new_size);
-	  /* See whether we can use the old buffer.  */
-	  if (__new_room + __new_size == __input_buffer)
-	    {
-	      __input_size += __new_size;
-	      __input_buffer = (char *) memcpy (__new_room, __input_buffer,
-					       __current_size);
-	    }
-	  else if (__input_buffer + __input_size == __new_room)
-	    __input_size += __new_size;
-	  else
-	    {
-	      __input_size = __new_size;
-	      __input_buffer = (char *) memcpy (__new_room, __input_buffer,
-						__current_size);
-	    }
-	}
-      __input_buffer[__current_size++] = __ch;
-    }
-  __input_buffer[__current_size++] = '\0';
-
-  /* Now compile the pattern.  */
-  __error = regcomp (__expr_ptr, __input_buffer, REG_NEWLINE);
-  if (__error != 0)
-    /* Oh well, we have to translate POSIX error codes.  */
-    switch (__error)
-      {
-      case REG_BADPAT:
-      case REG_ECOLLATE:
-      case REG_ECTYPE:
-      case REG_EESCAPE:
-      case REG_BADRPT:
-      case REG_EEND:
-      case REG_ERPAREN:
-      default:
-	/* There is no matching error code.  */
-	RETURN (36);
-      case REG_ESUBREG:
-	RETURN (25);
-      case REG_EBRACK:
-	RETURN (49);
-      case REG_EPAREN:
-	RETURN (42);
-      case REG_EBRACE:
-	RETURN (44);
-      case REG_BADBR:
-	RETURN (46);
-      case REG_ERANGE:
-	RETURN (11);
-      case REG_ESPACE:
-      case REG_ESIZE:
-	ERROR (50);
-      }
-
-  /* Everything is ok.  */
-  RETURN ((char *) (__expr_ptr->buffer + __expr_ptr->used));
-}
-
 void
 daqd_c::compile_regexp () 
 {
-  cur_regexp = ipregexp;
-  (void) compile (0, ipexpbuf, &ipexpbuf[ESIZE],'\0');
-  cur_regexp = dec_num_regexp;
-  (void) compile (0, dec_num_expbuf, &dec_num_expbuf[ESIZE],'\0');
+  (void)regcomp(&ip_regex, ipregexp, REG_NOSUB);
+  //(void)regcomp(&dec_num_regex, dec_num_regexp, REG_NOSUB);
 }
 
 /// See if the IP address is valid
@@ -1831,7 +1707,7 @@
 int
 daqd_c::is_valid_ip_address (char *str)
 {
-  return step (str, ipexpbuf);
+  return regexec(&ip_regex, str, 0, NULL, 0) == 0;
 }
 
 int
